"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[215],{7509:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));n(8209);const o={title:"Photo Stream",hide_title:!0},l="[Photo Stream](https://github.com/nacular/doodle-tutorials/tree/master/PhotoStream) Tutorial",r={unversionedId:"photostream",id:"photostream",title:"Photo Stream",description:"We will build a simple Doodle app that displays an infinite stream of photos that are lazily loaded from unsplash.com.",source:"@site/docs/photostream.mdx",sourceDirName:".",slug:"/photostream",permalink:"/doodle-tutorials/docs/photostream",draft:!1,tags:[],version:"current",frontMatter:{title:"Photo Stream",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Photos",permalink:"/doodle-tutorials/docs/photos"}},s={},d=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"Binding To Unsplash Data",id:"binding-to-unsplash-data",level:2},{value:"Presenting The Images",id:"presenting-the-images",level:2}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"photo-stream-tutorial"},(0,i.kt)("a",{parentName:"h1",href:"https://github.com/nacular/doodle-tutorials/tree/master/PhotoStream"},"Photo Stream")," Tutorial"),(0,i.kt)("p",null,"We will build a simple Doodle app that displays an infinite stream of photos that are lazily loaded from ",(0,i.kt)("a",{parentName:"p",href:"https://unsplash.com"},"unsplash.com"),".\nThe photos will be shown in a list that continuously grows as the user scrolls to the bottom."),(0,i.kt)("div",{style:{textAlign:"center",margin:"3em 0"}},(0,i.kt)("video",{autoPlay:!0,loop:!0,muted:!0,playsInline:!0,width:"400px"},(0,i.kt)("source",{type:"video/mp4",src:"/doodle-tutorials/photo_stream_desktop.mov"}),(0,i.kt)("p",null,"Your browser does not support the video element."))),(0,i.kt)("p",null,"The first thing we need is an ",(0,i.kt)("strong",{parentName:"p"},"Unsplash API")," key. Take a look at their ",(0,i.kt)("a",{parentName:"p",href:"https://unsplash.com/documentation"},"developer documentation")," to obtain one.\nA key is required to make API requests and fetch image urls."),(0,i.kt)("h2",{id:"project-setup"},"Project Setup"),(0,i.kt)("p",null,"We will use a JS only-setup for this app. Our app will use Ktor for the HTTP client and Kotlin Serialization to unmarshal the resulting JSON.\nWe also need Kotlin's Coroutines library to load images asynchronously."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/PhotoStream/build.gradle.kts"},(0,i.kt)("strong",{parentName:"a"},"build.gradle.kts"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'plugins {\n    kotlin("js"                  )\n    kotlin("plugin.serialization")\n}\n\nkotlin {\n    jsTargets()\n\n    val ktorVersion         : String by project\n    val doodleVersion       : String by project\n    val coroutinesVersion   : String by project\n    val serializationVersion: String by project\n\n    dependencies {\n        implementation("io.ktor:ktor-client-core:$ktorVersion"                                 )\n        implementation("io.ktor:ktor-client-serialization:$ktorVersion"                        )\n        implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core-js:$coroutinesVersion"   )\n        implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:$serializationVersion")\n\n        api("io.nacular.doodle:core:$doodleVersion"     )\n        api("io.nacular.doodle:browser:$doodleVersion"  )\n        api("io.nacular.doodle:controls:$doodleVersion" )\n        api("io.nacular.doodle:themes:$doodleVersion"   )\n    }\n}\n')),(0,i.kt)("h2",{id:"the-application"},"The Application"),(0,i.kt)("p",null,"Our application will be fairly simple. It will create a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/list/DynamicList.kt#L19"},(0,i.kt)("inlineCode",{parentName:"a"},"DynamicList")),"\nwith a data model bound to Unsplash's APIs. This list will be within a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/controls/panels/ScrollPanel.kt#L43"},(0,i.kt)("inlineCode",{parentName:"a"},"ScrollPanel")),"\nthat fits the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/core/Display.kt#L21"},(0,i.kt)("inlineCode",{parentName:"a"},"Display"))," height."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class PhotoStreamApp(display    : Display,\n                     themes     : ThemeManager,\n                     theme      : DynamicTheme,\n                     httpClient : HttpClient,\n                     imageLoader: ImageLoader): Application {\n    init {\n        // For scroll panel behavior\n        themes.selected = theme\n\n        val appScope    = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n        val imageHeight = 400.0\n\n        // List to hold images\n        val list = DynamicList(\n            model          = UnSplashDataModel(appScope, httpClient, imageLoader),\n            itemVisualizer = itemVisualizer { image, recycledView, _ -> when(recycledView) {\n                is CenterCroppedPhoto -> recycledView.also { recycledView.image = image }\n                else                  -> CenterCroppedPhoto(image)\n            } }\n        ).apply {\n            behavior      = BasicListBehavior(rowHeight = imageHeight)\n            cellAlignment = fill\n        }\n\n        display += ScrollPanel(list).apply {\n            // Ensure list's width is equal to scroll-panel's\n            contentWidthConstraints = { parent.width }\n        }\n\n        display.layout = constrain(display.children[0]) {\n            it.width   = min(parent.width, constant(imageHeight))\n            it.height  = parent.height\n            it.centerX = parent.centerX\n        }\n    }\n\n    override fun shutdown() {}\n}\n")),(0,i.kt)("p",null,"DynamicList monitors its model for changes and updates whenever items are added, removed, or moved. This means we can simply change the underlying\nmodel to get a list that grows."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"DynamicList"),", like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/list/List.kt#L98"},(0,i.kt)("inlineCode",{parentName:"a"},"List")),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/list/MutableList.kt#L30"},(0,i.kt)("inlineCode",{parentName:"a"},"MutableList")),"\nrecycle their contents to avoid rendering items that are not displayed. The ",(0,i.kt)("inlineCode",{parentName:"p"},"scrollCache")," constructor parameter controls the amount of items in the\nbuffer. Passing nothing means we get a default of 10 items cached beyond what is visible.")),(0,i.kt)("h2",{id:"binding-to-unsplash-data"},"Binding To Unsplash Data"),(0,i.kt)("p",null,"DynamicList requires a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/ListModel.kt#L40"},(0,i.kt)("inlineCode",{parentName:"a"},"DynamicListModel")),"\nto hold its data, so we need to create one that binds to Unsplash."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'class UnSplashDataModel(private val accessToken: String = "YOUR_ACCESS_TOKEN", /*...*/): DynamicListModel<Image> {\n    // ...\n\n    private var currentPage: Int by observable(-1) { /*...*/ }\n\n    private val pageSize               = 5\n    private val unsplashLocation get() = "https://api.unsplash.com/photos/?client_id=$accessToken&page=$currentPage&per_page=$pageSize"\n\n    override val size get() = loadedImages.size\n\n    override val changed = SetPool<ModelObserver<Image>>()\n\n    // Internal list used to cache images loaded from unsplash\n    private val loadedImages = ObservableList<Image>()\n\n    override fun get(index: Int): Image? = loadedImages.getOrNull(index).also {\n        // ...\n    }\n\n    override fun contains(value: Image           ) = value in loadedImages\n    override fun iterator(                       ) = loadedImages.iterator()\n    override fun section (range: ClosedRange<Int>) = loadedImages.subList(range.start, range.endInclusive + 1)\n}\n')),(0,i.kt)("p",null,"Our model will cache a local ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/utils/Observables.kt#L41"},(0,i.kt)("inlineCode",{parentName:"a"},"ObservableList")),"\nof images via ",(0,i.kt)("inlineCode",{parentName:"p"},"loadedImages"),". This list will provide the model state our list uses to render. The model will then fetch paginated images\nfrom Unsplash and load the resulting urls asynchronously into this list."),(0,i.kt)("p",null,"We track the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentPage")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pageSize")," to fetch a growing list of pages from Unsplash. We fetch a new page whenever the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentPage")," is\nupdated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class UnSplashDataModel(private val scope: CoroutineScope, /*...*/): DynamicListModel<Image> {\n    // ...\n\n    private var httpRequestJob: Job? by observable(null) { _,old,_ ->\n        old?.cancel()\n    }\n\n    private var currentPage: Int by observable(-1) { _,_ ->\n        fetchActive    = true\n        httpRequestJob = scope.launch {\n            val results = client.get<List<UnsplashPhoto>>(unsplashLocation)\n\n            loadedImages.addAll(results.mapNotNull { imageLoader.load(it.urls.small) })\n\n            fetchActive = false\n\n            if (nextPageNeeded) {\n                nextPageNeeded  = false\n                currentPage    += 1\n            }\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"Fetches are performed using Ktor's HttpClient configured to read JSON data. These reads are done via Kotlin Serialization into the ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsplashPhoto"),"\ndata class. We only use the ",(0,i.kt)("inlineCode",{parentName:"p"},"small")," value in the ",(0,i.kt)("inlineCode",{parentName:"p"},"urls")," property from the JSON response, so our data classes are much simpler than the full\nUnsplash API."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class UnSplashDataModel(httpClient: HttpClient, /*...*/): DynamicListModel<Image> {\n    // ...\n\n    @Serializable\n    data class Urls(val small: String)\n\n    @Serializable\n    data class UnsplashPhoto(val id: String, val urls: Urls)\n\n    // HTTP client configured to read JSON  returned from unsplash\n    private val client = httpClient.config {\n        install(JsonFeature) {\n            serializer = KotlinxSerializer(Json { ignoreUnknownKeys = true })\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"loadedImages")," list triggers an event whenever we add a new set of images to it. We use this fact to notify of changes to the model, which get\nreflected by the ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicList"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class UnSplashDataModel(/*...*/): DynamicListModel<Image> {\n    // ...\n\n    override val changed = SetPool<ModelObserver<Image>>()\n\n    // Internal list used to cache images loaded from unsplash\n    private val loadedImages = ObservableList<Image>().also {\n        it.changed += { _ ,removed, added, moved ->\n            // notify model observers whenever the underlying list changes (due to image loads)\n            changed.forEach {\n                it(this, removed, added, moved)\n            }\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"Finally, we need to decide when to fetch more images. We do this whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," is called on the last image of the model. This happens when\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicList")," needs to present that image, and is a good indication that it has reached the end."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class UnSplashDataModel(/*...*/): DynamicListModel<Image> {\n    // ...\n\n    override fun get(index: Int): Image? = loadedImages.getOrNull(index).also {\n        // Load the next page if the last image is fetched from the model\n        if (index == size - 1) {\n            when {\n                fetchActive -> nextPageNeeded  = true\n                else        -> currentPage    += 1\n            }\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("h2",{id:"presenting-the-images"},"Presenting The Images"),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicList")," holds a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"Image")," items, but these are not ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),"s. Which means we need a way of visualizing them. Many Doodle containers\nuse this concept of an ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/ItemVisualizer.kt#L13"},(0,i.kt)("inlineCode",{parentName:"a"},"ItemVisualizer")),".\nIt is essentially a class that maps from some type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," based on a set of inputs. ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicList")," takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"itemVisualizer")," in its\nconstructor that can be used by is ",(0,i.kt)("inlineCode",{parentName:"p"},"behavior")," to render the contents of each row. Our app uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"BasicListBehavior")," to configure our list.\nInternally, that behavior takes the list's visualizer and creates a new ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," that is wrapped in another that represents the row itself. So it\nis sufficient to specify a visualizer that renders our images."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"It is also possible to change the way ",(0,i.kt)("inlineCode",{parentName:"p"},"BasicListBehavior")," (and any ",(0,i.kt)("inlineCode",{parentName:"p"},"ListBehavior"),") represents its rows by specifying it's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/list/List.kt#L47"},(0,i.kt)("inlineCode",{parentName:"a"},"RowGenerator")),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class PhotoStreamApp(/*...*/): Application {\n    init {\n        // ...\n\n        val list = DynamicList(\n            model          = UnSplashDataModel(appScope, httpClient, imageLoader),\n            itemVisualizer = itemVisualizer { image, recycledView, _ -> when(recycledView) {\n                is CenterCroppedPhoto -> recycledView.also { recycledView.image = image }\n                else                  -> CenterCroppedPhoto(image)\n            } }\n        ).apply {\n            behavior      = BasicListBehavior(rowHeight = imageHeight)\n            cellAlignment = fill\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"ItemVisualizer")," is designed to support recycling. Each invocation may provide a recycled View that might be reusable for the new item. This lets\nus reuse the ",(0,i.kt)("inlineCode",{parentName:"p"},"CenterCroppedPhoto")," instances as the list scrolls.")),(0,i.kt)("p",null,"We will render each image as with a center-crop using ",(0,i.kt)("inlineCode",{parentName:"p"},"CenterCroppedPhoto"),". This class holds an image that it renders with a centered square crop. The\ncrop square's length is equal to the image's width or height (whichever is smaller). That center region is then scaled to fit the cropped photo View's\nbounds."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class CenterCroppedPhoto(image: Image): View() {\n    private lateinit var centerCrop: Rectangle\n\n    var image: Image = image\n        set(new) {\n            field        = new\n            val cropSize = min(image.width, image.height)\n            centerCrop   = Rectangle((image.width - cropSize) / 2, (image.height - cropSize) / 2, cropSize, cropSize)\n\n            rerender()\n        }\n\n    init {\n        this.image = image // ensure setter called, so centerCrop initialized\n    }\n\n    override fun render(canvas: Canvas) {\n        canvas.image(image, source = centerCrop, destination = bounds.atOrigin)\n    }\n}\n")))}m.isMDXComponent=!0}}]);