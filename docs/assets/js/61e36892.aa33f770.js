"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[931],{4429:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>w,contentTitle:()=>v,default:()=>T,frontMatter:()=>f,metadata:()=>x,toc:()=>b});var o=t(4848),i=t(8453),a=t(1470),r=t(9365);t(1432);const s='plugins {\n    kotlin("multiplatform")\n}\n\nkotlin {\n    // Defined in buildSrc/src/main/kotlin/Common.kt\n    jsTargets    ()\n    jvmTargets   ()\n    wasmJsTargets()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                api(libs.coroutines.core)\n\n                api(libs.doodle.controls )\n                api(libs.doodle.animation)\n            }\n        }\n    }\n}',l='plugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    jsTargets    (executable = true)\n    wasmJsTargets(executable = true)\n    jvmTargets   (                 )\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation(project(":TimedCards"))\n            }\n        }\n\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.doodle.browser)\n            }\n        }\n\n\n        jvmMain.dependencies {\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n    }\n}\n\napplication {\n    mainClass.set("MainKt")\n}\n\ninstallFullScreenDemo("Development")\ninstallFullScreenDemo("Production" )',d="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.easeInOutCubic\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.carousel.Carousel\nimport io.nacular.doodle.controls.carousel.CarouselBehavior\nimport io.nacular.doodle.controls.carousel.dampedTransitioner\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.center\nimport io.nacular.doodle.core.then\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.event.KeyCode.Companion.ArrowLeft\nimport io.nacular.doodle.event.KeyCode.Companion.ArrowRight\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.event.PointerMotionListener.Companion.dragged\nimport io.nacular.doodle.focus.FocusManager\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Strong\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.scheduler.AnimationScheduler\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.time.Timer\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.cancel\nimport kotlinx.coroutines.launch\n\n//sampleStart\nclass TimedCardsApp(\n                display     : Display,\n                focusManager: FocusManager,\n                themeManager: ThemeManager,\n                theme       : Theme,\n    private val fonts       : FontLoader,\n    private val images      : ImageLoader,\n    private val timer       : Timer,\n    private val animate     : Animator,\n    private val textMetrics : TextMetrics,\n    private val scheduler   : AnimationScheduler,\n                uiDispatcher: CoroutineDispatcher,\n): Application {\n\n    private val appScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n\n    private lateinit var appFonts: Fonts\n    private lateinit var carousel: Carousel<CardData, *>\n\n    init {\n        appScope.launch(uiDispatcher) {\n            themeManager.selected = theme\n\n            appFonts = loadFonts(fonts)\n\n            // Carousel containing all the content\n            carousel = Carousel(\n                createModel(images),\n                itemVisualizer { item, previous, context ->\n                    when (previous) {\n                        is Card -> previous.apply { update(item, context) }\n                        else    -> Card(item, context, appFonts) { itemSize(carousel.size) }\n                    }\n                }\n            ).apply {\n                wrapAtEnds = true\n                behavior   = object: CarouselBehavior<CardData> {\n                    // Presenter controlling which items are shown and how they adjust\n                    // as the Carousel moves between frames.\n                    override val presenter = CardPresenter<CardData> { itemSize(it) }\n\n                    // Responsible for automatic movement between frames\n                    override val transitioner = dampedTransitioner<CardData>(timer, scheduler) { _,_,_, update ->\n                        animate(0f to 1f, using = tweenFloat(easeInOutCubic, duration = 1.25 * seconds)) {\n                            update(it)\n                        }\n                    }\n                }\n\n                keyChanged += pressed {\n                    when (it.code) {\n                        ArrowLeft  -> next    () // Move Carousel forward one\n                        ArrowRight -> previous() // Move Carousel back one\n                    }\n                }\n\n                var touchLocation = Origin\n\n                // start/stop manual movement of the Carousel on pointer press/release\n                pointerChanged += on(\n                    pressed  = {\n                        touchLocation = toLocal(it.location, it.target)\n                        startManualMove()\n                        it.consume()\n                    },\n                    released = { completeManualMove() },\n                )\n\n                // perform manual movement of the Carousel\n                pointerMotionChanged += dragged {\n                    if (it.source == this) {\n                        moveManually(toLocal(it.location, it.target) - touchLocation)\n                        it.consume()\n                    }\n                }\n            }\n\n            val buttonControls = ButtonControls(carousel, textMetrics, appFonts)\n\n            display += carousel\n            display += buttonControls\n\n            display.layout = constrain(carousel, buttonControls) { carousel_, controls ->\n                (carousel_.width  eq CAROUSEL_MAX_WIDTH                  )..Strong\n                carousel_.height eq carousel_.width  * MAIN_ASPECT_RATIO\n                carousel_.width  eq carousel_.height / MAIN_ASPECT_RATIO\n\n                carousel_.width  lessEq parent.width\n                carousel_.height lessEq parent.height\n                carousel_.center eq     parent.center\n\n                controls.height eq CONTROLS_HEIGHT\n                controls.bottom eq carousel_.bottom\n            }.then {\n                // done after Carousel's size is properly determined in previous block, otherwise itemSize(carousel.size)\n                // won't be accurate since it will use a captured value before the size is updated\n                // by the constraint.\n                buttonControls.x     = carousel.center.x - itemSize(carousel.size).width / 2\n                buttonControls.width = carousel.bounds.right - display.children[1].x\n            }\n\n            focusManager.requestFocus(carousel)\n        }\n    }\n\n    override fun shutdown() {\n        appScope.cancel()\n    }\n}\n//sampleEnd",c="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.controls.carousel.Carousel\nimport io.nacular.doodle.controls.carousel.CarouselBehavior\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.Vector2D\nimport io.nacular.doodle.geometry.lerp\nimport io.nacular.doodle.layout.Insets\nimport kotlin.math.abs\nimport kotlin.math.min\n\n/**\n * Presenter responsible for displaying the contents of the Carousel\n */\n//sampleStart\nclass CardPresenter<T>(private val spacing: Double = 20.0, private val itemSize: (Size) -> Size): CarouselBehavior.Presenter<T>() {\n    /**\n     * Determines what is shown in the Carousel\n     */\n    override fun present(\n        carousel         : Carousel<T, *>,\n        position         : Position,\n        progressToNext   : Float,\n        supplementalViews: List<View>,\n        items            : (at: Position) -> Carousel.PresentedItem?\n    ): Presentation {\n        var zOrder          = 0\n        val results         = mutableListOf<Carousel.PresentedItem>()\n        val itemSize        = itemSize(carousel.size)\n        var currentBounds   = null as Rectangle?\n        var currentPosition = position as Position?\n        val mainBounds      = Rectangle(carousel.size).inset(-10.0)\n\n        // Add selected card\n        currentPosition?.let(items)?.let {\n            // Image is outset by 10, and grows as we progress to the next frame\n            it.bounds       = mainBounds.inset(Insets(-progressToNext * itemSize.width * 0.5))\n            it.zOrder       = zOrder++\n            currentPosition = currentPosition?.next\n\n            results += it\n        }\n\n        // Add the first small card\n        currentPosition?.let(items)?.let { item ->\n            // bounds when exactly at frame\n            val bounds = Rectangle(\n                Point(\n                    (carousel.width - itemSize.width) / 2,\n                    (carousel.height - itemSize.height - CONTROLS_HEIGHT)\n                ),\n                itemSize\n            )\n\n            // bounds gradually grows toward main bounds\n            item.bounds = lerp(bounds, mainBounds, min(1f, progressToNext * 2))\n\n            // increase item zOrder so they sort properly\n            item.zOrder = zOrder++\n\n            // next item is shifted over towards this slot as progress increases\n            currentBounds   = bounds.run { at(x - progressToNext * (width + spacing)) }\n            currentPosition = currentPosition?.next\n\n            results += item\n        }\n\n        // add the remaining cards to the right of the first small one\n        do {\n            currentPosition?.let(items)?.let { item ->\n                // each item is offset to the right of the second, with a spacing that varies w/ progress\n                currentBounds = currentBounds?.run {\n                    at(right + spacing + -abs(progressToNext - 0.5f) * 3 * spacing + 3 * spacing / 2)\n                }\n\n                currentBounds?.let { item.bounds = it }\n\n                // increase item zOrder so they sort properly\n                item.zOrder = zOrder++\n\n                results += item\n            } ?: break\n        } while (\n            // continue until there are no more items to show\n            (currentBounds?.right ?: 0.0) + spacing < carousel.size.width &&\n            currentPosition?.next?.also { currentPosition = it } != null\n        )\n\n        return Presentation(items = results)\n    }\n\n    override fun distanceToNext(\n        carousel: Carousel<T, *>,\n        position: Position,\n        offset  : Vector2D,\n        items   : (Position) -> Carousel.PresentedItem?\n    ): Distance = Distance(Vector2D(x = 1), carousel.width)\n}\n//sampleEnd",p='package io.nacular.doodle.examples\n\nimport io.nacular.doodle.controls.buttons.Button\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.carousel.Carousel\nimport io.nacular.doodle.controls.theme.CommonButtonBehavior\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.AffineTransform\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.inscribed\nimport io.nacular.doodle.geometry.inset\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.system.Cursor.Companion.Pointer\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.times\nimport kotlin.math.min\n\nclass ButtonControls(carousel: Carousel<*, *>, textMetrics: TextMetrics, private val fonts: Fonts): View() {\n\n    private val stroke = Stroke(White opacity 0.75f, 0.5)\n\n    // Let pointer pass through everywhere else\n    override fun contains(point: Point) = (point - position).let { localPoint -> children.any { it.contains(localPoint) } }\n\n    init {\n        //sampleStart\n        children += leftButton  { carousel.previous() } // Skip to the previous frame\n        children += rightButton { carousel.next    () } // Skip to the next frame\n\n        // Progress Bar\n        children += view {\n            contains = { false }\n            render   = {\n                val progress = (carousel.nearestItem + carousel.progressToNextItem) / carousel.numItems\n\n                rect(bounds.atOrigin,                     fill = stroke.fill           )\n                rect(Rectangle(progress * width, height), fill = Color(0xE8B950u).paint)\n            }\n\n            carousel.progressChanged += { rerender() }\n        }\n\n        // Frame Number\n        children += view {\n            font     = fonts.mediumBoldFont\n            contains = { false }\n            render   = {\n                val currentIndex = "0${(carousel.nearestItem    ) % carousel.numItems + 1}"\n                val nextIndex    = "0${(carousel.nearestItem + 1) % carousel.numItems + 1}"\n                val size1        = textMetrics.size(currentIndex, font)\n                val size2        = textMetrics.size(nextIndex,    font)\n\n                val x1 = (width  - size1.width ) / 2 - carousel.progressToNextItem * width\n                val y1 = (height - size1.height) / 2\n                val x2 = (width  - size2.width ) / 2 - carousel.progressToNextItem * width + width\n                val y2 = (height - size2.height) / 2\n\n                text(currentIndex, at = Point(x1, y1), font = font, fill = White.paint)\n                text(nextIndex,    at = Point(x2, y2), font = font, fill = White.paint)\n            }\n\n            carousel.progressChanged += { rerender() }\n        }\n//sampleEnd\n\n        layout = constrain(children[0], children[1], children[2], children[3]) { left, right, progress, text ->\n            left.left    eq 0\n            left.width   eq left.height\n            left.height  eq 45\n            left.centerY eq parent.centerY\n\n            right.left    eq left.right + 10\n            right.width   eq left.width\n            right.height  eq left.height\n            right.centerY eq left.centerY\n\n            progress.left    eq right.right   + 20\n            progress.right   eq text.left - 20\n            progress.height  eq 1.5\n            progress.centerY eq right.centerY\n\n            text.top    eq 0\n            text.width  eq 40\n            text.right  eq parent.right - 20\n            text.height eq parent.height\n        }\n    }\n\n    private fun leftButton (onFired: (Button) -> Unit) = skipButton(isRightButton = false, onFired)\n    private fun rightButton(onFired: (Button) -> Unit) = skipButton(isRightButton = true,  onFired)\n\n    private fun skipButton(isRightButton: Boolean, onFired: (Button) -> Unit) = PushButton().apply {\n        font          = fonts.smallRegularFont\n        fired        += onFired\n        cursor        = Pointer\n        behavior      = buttonRenderer(right = isRightButton)\n        acceptsThemes = false\n\n        return this\n    }\n\n    private fun buttonRenderer(right: Boolean = true) = object: CommonButtonBehavior<Button>(null) {\n        override fun contains(view: Button, point: Point): Boolean =\n            point in Circle(view.bounds.center, min(view.width, view.height) / 2)\n\n        override fun render(view: Button, canvas: Canvas) {\n            val circle   = Circle(view.bounds.atOrigin.center, min(view.width, view.height) / 2)\n            val triangle = AffineTransform.Identity.scale(around = circle.center, x = 0.7)(circle.inset(circle.radius * 0.75).inscribed(\n                3,\n                if (right) 90 * Angle.degrees else 270 * Angle.degrees\n            )!!)\n\n            val points = listOf(triangle.points[2], triangle.points[0], triangle.points[1])\n\n            canvas.circle(circle.inset(stroke.thickness / 2), stroke = stroke)\n            canvas.path  (points, Stroke(stroke.fill, 4 * stroke.thickness))\n        }\n    }\n}\n',u="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.accessibility.ImageRole\nimport io.nacular.doodle.controls.carousel.CarouselItem\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.core.then\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.lerp\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.image.width\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.utils.Dimension\nimport io.nacular.doodle.utils.TextAlignment\nimport io.nacular.doodle.utils.observable\nimport kotlin.math.min\n\n/**\n * Data objects that are stored in the Carousel's model. These are converted to [Card]s.\n */\ndata class CardData(val image: Image, val header: String, val title: String, val clip: Rectangle) {\n    val width get() = image.width\n}\n\n/**\n * Represents each item in the Carousel. These are created by the [ItemVisualizer][io.nacular.doodle.controls.ItemVisualizer]\n * passed to the Carousel.\n */\n//sampleStart\nclass Card(\n    private var data           : CardData,\n    private var context        : CarouselItem,\n    private val fonts          : Fonts,\n    private val itemInitialSize: () -> Size,\n): View(accessibilityRole = ImageRole()) {\n\n    private val smallHeader = header(data.header, fonts.smallBoldFont      )\n    private val smallTitle  = title(data.title,   fonts.smallBoldFont, -0.8)\n    private val largeText   = container {\n        +view { render = { rect(bounds.atOrigin, fill = Color.White.paint) } }\n        +header(data.header, fonts.largeRegularFont   )\n        +title (data.title,  fonts.largeBoldFont, -1.0)\n\n        layout = constrain(children[0], children[1], children[2]) { block, header, title ->\n            block.edges eq Rectangle(15, 3)\n\n            header.top  eq block.bottom + 8\n            header.left eq block.left\n            header.width.preserve\n            header.height.preserve\n\n            title.top   eq header.bottom + 7\n            title.left  eq 0\n            title.right eq parent.right\n            title.height.preserve\n        }.then {\n            this.height = children.last().bounds.bottom\n        }\n\n        opacity = 0f\n    }\n\n    private var progress by observable(0f) { _, new ->\n        largeText.opacity = when {\n            new >= 0.5f -> (new - 0.5f) * 2\n            else -> 0f\n        }\n\n        relayout()\n        rerender()\n    }\n\n    init {\n        size               = data.image.size\n        enabled            = false\n        clipCanvasToBounds = false\n\n        children += container {\n            +view { render = { rect(bounds.atOrigin, fill = Color.White.paint) } }\n            +smallHeader\n            +smallTitle\n\n            layout = constrain(children[0], smallHeader, smallTitle) { bar, header, title ->\n                bar.edges eq Rectangle(7.0, 1.5)\n\n                header.top  eq bar.bottom + 6\n                header.left eq bar.left\n                header.width.preserve\n                header.height.preserve\n\n                title.top   eq header.bottom + 7\n                title.left  eq 0\n                title.right eq parent.right\n                title.height.preserve\n            }.then {\n                this.height = smallTitle.bounds.bottom\n            }\n        }\n        children += largeText\n\n        layout = constrain(children[0], children[1]) { smallText, largeText ->\n            smallText.left   eq parent.centerX - itemInitialSize().width / 2 + 10\n            smallText.right  eq parent.right  - 10\n            smallText.bottom eq parent.bottom - 20 + progress * 800\n            smallText.height.preserve\n\n            val largeTextOffset = when {\n                progress >= 0.5f -> 20 * (1 - (progress - 0.5f) * 2)\n                else             -> 0f\n            }\n\n            largeText.left  eq  50\n            largeText.width eq 500\n            largeText.centerY eq parent.centerY + 5 + largeTextOffset\n            largeText.height.preserve\n        }\n\n        updateProgress()\n    }\n\n    /**\n     * Called when a Card needs to be recycled to display a new [CardData] or [CarouselItem].\n     */\n    fun update(data: CardData, context: CarouselItem) {\n        this.data    = data\n        this.context = context\n\n        updateProgress()\n    }\n\n    override fun render(canvas: Canvas) {\n        val clip   = lerp(data.clip, Rectangle(data.width, data.width * MAIN_ASPECT_RATIO), min(1f, progress * 2f))\n        val radius = 10.0 * (1 - progress * 1.5)\n\n        canvas.outerShadow(blurRadius = 10.0, vertical = 10.0, horizontal = 10.0, color = Black opacity 0.5f) {\n            val w = height * clip.width/clip.height\n\n            image(\n                image       = data.image,\n                source      = clip,\n                radius      = radius,\n                destination = Rectangle((width - w) / 2, 0.0, w, height)\n            )\n        }\n    }\n\n    private fun updateProgress() {\n        progress = when (context.index) {\n            context.nearestItem -> 1f\n            (context.nearestItem + 1) % context.numItems -> context.progressToNextItem\n            else -> 0f\n        }\n    }\n\n    private fun header(text: String, font: Font) = Label(text).apply {\n        this.font     = font\n        letterSpacing = 0.0\n    }\n\n    private fun title(text: String, font: Font, letterSpacing: Double) = Label(text).apply {\n        this.font          = font\n        this.letterSpacing = letterSpacing\n        wrapsWords         = true\n        textAlignment      = TextAlignment.Start\n        lineSpacing        = 1.1f\n        fitText            = setOf(Dimension.Height)\n    }\n}\n//sampleEnd",m='package io.nacular.doodle.examples\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.AnimatorImpl\nimport io.nacular.doodle.application.Modules.Companion.FontModule\nimport io.nacular.doodle.application.Modules.Companion.ImageModule\nimport io.nacular.doodle.application.Modules.Companion.KeyboardModule\nimport io.nacular.doodle.application.Modules.Companion.ModalModule\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.coroutines.Dispatchers\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicLabelBehavior\nimport org.kodein.di.DI.Module\nimport org.kodein.di.bindSingleton\nimport org.kodein.di.instance\n\n/**\n * Creates a [TimedCardsApp]\n */\n//sampleStart\nfun main() {\n    application(modules = listOf(\n        FontModule,\n        ImageModule,\n        ModalModule,\n        PointerModule,\n        KeyboardModule,\n        basicLabelBehavior(White),\n        Module(name = "App") {\n            bindSingleton<Animator> { AnimatorImpl(instance(), instance()) }\n        }\n    )) {\n        // load app\n        TimedCardsApp(\n            display      = instance(),\n            focusManager = instance(),\n            themeManager = instance(),\n            theme        = instance(),\n            images       = instance(),\n            fonts        = instance(),\n            animate      = instance(),\n            textMetrics  = instance(),\n            timer        = instance(),\n            scheduler    = instance(),\n            uiDispatcher = Dispatchers.UI\n        )\n    }\n}\n//sampleEnd';var h=t(854),g=t(9053);const f={title:"Timed Cards",hide_title:!0},v="TimedCards Tutorial",x={id:"timedcards",title:"Timed Cards",description:'This is a simple app that shows the flexibility of Doodle Carousels. It is inspired by Giulio Cuscito\'s "Timed Cards Opening". This app is multi-platform, which means it will run in the browser and as a desktop application.',source:"@site/docs/timedcards.mdx",sourceDirName:".",slug:"/timedcards",permalink:"/doodle-tutorials/docs/timedcards",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Timed Cards",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/doodle-tutorials/docs/introduction"},next:{title:"Animating Tab Strip",permalink:"/doodle-tutorials/docs/tabstrip"}},w={},b=[{value:"Project Setup",id:"project-setup",level:2},{value:"Launching on Web and Desktop",id:"launching-on-web-and-desktop",level:2},{value:"Defining Our Application",id:"defining-our-application",level:2},{value:"The Card Presenter",id:"the-card-presenter",level:2},{value:"Transitioner",id:"transitioner",level:2},{value:"Carousel Interactions",id:"carousel-interactions",level:2},{value:"Cards",id:"cards",level:2}];function C(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",mermaid:"mermaid",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"timedcards-tutorial",children:[(0,o.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/tree/master/TimedCards",children:"TimedCards"})," Tutorial"]}),"\n",(0,o.jsxs)(n.p,{children:["This is a simple app that shows the flexibility of Doodle Carousels. It is inspired by ",(0,o.jsx)(n.a,{href:"https://dribbble.com/shots/11012652--Timed-Cards-Opening",children:'Giulio Cuscito\'s "Timed Cards Opening"'}),". This app is multi-platform, which means it will run in the browser and as a desktop application."]}),"\n",(0,o.jsxs)(n.p,{children:["The entire app rests on ",(0,o.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#carousel",children:"Doodle's powerful Carousel APIs"})," to create the layout and smooth, perfectly-timed transitions."]}),"\n",(0,o.jsx)(g.I,{function:"timedCards",height:"538.875"}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["You can also see the full-screen app here: ",(0,o.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/timedcards",children:"JavaScript"}),", ",(0,o.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/timedcards_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,o.jsxs)(n.p,{children:["This app (like the others in this tutorial) is created as a multi-platform library, with a multiplatform launcher that depends on it. This is not necessary to use Doodle. You could create a single multiplatform build with the common parts of your app in ",(0,o.jsx)(n.code,{children:"commonMain"})," etc.. This setup is used here because the app are also launched by an app within ",(0,o.jsx)(n.code,{children:"DocApps"})," when embedding it like below. Therefore, we need a pure library for the app. This is why there is an app and a runner."]}),"\n",(0,o.jsx)(n.mermaid,{value:" classDiagram\n      TimedCards      <|-- TimedCardsRunner\n      TimedCards      <|-- DocApps\n      TimedCardsRunner: commonMain.resources\n      TimedCardsRunner: jvmMain.main\n      TimedCardsRunner: jsMain.main\n      DocApps         : main\n      TimedCards      : commonMain\n      TimedCards      : jvmMain\n      TimedCards      : jsMain"}),"\n",(0,o.jsxs)(a.A,{children:[(0,o.jsxs)(r.A,{value:"TimedCards",children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/TimedCards/build.gradle.kts",children:(0,o.jsx)(n.strong,{children:"build.gradle.kts"})})}),(0,o.jsx)(h.v,{children:s})]}),(0,o.jsxs)(r.A,{value:"TimedCardsRunner",children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/TimedCardsRunner/build.gradle.kts",children:(0,o.jsx)(n.strong,{children:"build.gradle.kts"})})}),(0,o.jsx)(h.v,{children:l})]})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Build uses ",(0,o.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file."]})}),"\n",(0,o.jsx)(n.h2,{id:"launching-on-web-and-desktop",children:"Launching on Web and Desktop"}),"\n",(0,o.jsxs)(n.p,{children:["Doodle apps can be ",(0,o.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. We defined our app logic in a multi-platform ",(0,o.jsx)(n.code,{children:"TimedCards"})," library (no ",(0,o.jsx)(n.code,{children:"main"})," functions), so it can be used on both platforms. Notice that we are only using a library here because we also want to run the TimedCards in our documentation app. That app will run it as an embedded Web app, which becomes easier if it is a library. Otherwise, we could have defined our platform ",(0,o.jsx)(n.code,{children:"main"})," functions directly in the ",(0,o.jsx)(n.code,{children:"TimedCards"})," module. Instead, we created a separate ",(0,o.jsx)(n.code,{children:"TimedCardsRunner"})," module that contains our ",(0,o.jsx)(n.code,{children:"main"})," functions."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"main.kt"})}),"\n",(0,o.jsx)(h.v,{children:m}),"\n",(0,o.jsx)(n.h2,{id:"defining-our-application",children:"Defining Our Application"}),"\n",(0,o.jsxs)(n.p,{children:["All Doodle apps must implement the ",(0,o.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:(0,o.jsx)(n.code,{children:"Application"})})," interface. The framework will then initialize our app via the constructor. Our app will be fairly simple: just create an instance of our calculator and add it to the display."]}),"\n",(0,o.jsxs)(n.p,{children:["Doodle apps can be defined in ",(0,o.jsx)(n.code,{children:"commonMain"}),", since they do not require any platform-specific dependencies. Therefore, we will do\nthe same and place ours in ",(0,o.jsx)(n.code,{children:"commonMain/kotlin/io/nacular/doodle/examples"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/TimedCards/src/commonMain/kotlin/io/nacular/doodle/examples/TimedCardsApp.kt#L43",children:(0,o.jsx)(n.strong,{children:"TimedCardsApp.kt"})})}),"\n",(0,o.jsx)(h.v,{children:d}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["Notice that ",(0,o.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,o.jsx)(n.h2,{id:"the-card-presenter",children:"The Card Presenter"}),"\n",(0,o.jsxs)(n.p,{children:["This app has a single Carousel that contains almost all of the UI elements. And that Carousel is driven by a custom ",(0,o.jsx)(n.code,{children:"Presenter"})," that manages the layout and animation of the cards within it."]}),"\n",(0,o.jsx)(n.p,{children:"The cards in the Carousel can be in 3 key positions. The first position is that of the selected card, which fills the Carousel and has larger text displayed to the left. The first small card is in the second important position. And the cards to the right of the first card a all in the last key position."}),"\n",(0,o.jsxs)(n.p,{children:["The second position is treated as special because it has to support the transition from small to large card. Therefore the ",(0,o.jsx)(n.code,{children:"CardPresenter"})," needs to track it directly."]}),"\n",(0,o.jsx)(h.v,{children:c}),"\n",(0,o.jsx)(n.p,{children:"This presenter is all it takes to handle all the positioning for the Carousel's contents."}),"\n",(0,o.jsx)(n.h2,{id:"transitioner",children:"Transitioner"}),"\n",(0,o.jsx)(n.p,{children:"Carousel's also expose a way to manage their automatic movement between frames. This includes changing frames or when a manual move is completed and the Carousel needs to move to a valid frame."}),"\n",(0,o.jsxs)(n.p,{children:["This app uses the ",(0,o.jsx)(n.code,{children:"DampedTransitioner"})," with an animation for auto frame selection. This Transitioner provides a critically damped spring behavior to smoothly complete manual movement (which happens after a swipe for example). And the animation provided by our app is used during frame jumps."]}),"\n",(0,o.jsx)(h.v,{children:"\nbehavior = object: CarouselBehavior<CardData> {\n    override val presenter = CardPresenter<CardData> { itemSize(it) }\n\n\n    override val transitioner = dampedTransitioner<CardData>(timer, scheduler) { _,_,_, update ->\n        animate(0f to 1f, using = tweenFloat(easeInOutCubic, duration = 1.25 * seconds)) {\n            update(it)\n        }\n    }\n}\n"}),"\n",(0,o.jsx)(n.h2,{id:"carousel-interactions",children:"Carousel Interactions"}),"\n",(0,o.jsxs)(n.p,{children:["The app uses a floating View with controls to interact with the Carousel and monitor its progress. The two buttons trigger ",(0,o.jsx)(n.code,{children:"Carousel.previous()"})," and ",(0,o.jsx)(n.code,{children:"Carousel.next()"})," to switch back and forth between frames. While the progress bar and frame text listen for ",(0,o.jsx)(n.code,{children:"Carousel.progressChanged"})," and update accordingly."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Button Controls"})}),"\n",(0,o.jsx)(h.v,{children:p}),"\n",(0,o.jsx)(n.h2,{id:"cards",children:"Cards"}),"\n",(0,o.jsx)(n.p,{children:"The cards shown in the Carousel are very dynamic and change what they show when moving from their small to large size."}),"\n",(0,o.jsx)(h.v,{children:u})]})}function T(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(C,{...e})}):C(e)}}}]);