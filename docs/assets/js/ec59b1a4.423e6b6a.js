"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[783],{5620:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>p,toc:()=>h});var a=n(7462),i=(n(7294),n(3905)),o=(n(8209),n(5488)),s=n(5162),l=n(3138);const r={title:"Contacts",hide_title:!0},c="[Contacts](https://github.com/nacular/doodle-tutorials/tree/master/Contacts) Tutorial",p={unversionedId:"contacts",id:"contacts",title:"Contacts",description:"This tutorial shows how you might build a simple app to track a list of contacts, each with a name and phone number. It is inspired by phonebook-pi.vercel.app, which",source:"@site/docs/contacts.mdx",sourceDirName:".",slug:"/contacts",permalink:"/doodle-tutorials/docs/contacts",draft:!1,tags:[],version:"current",frontMatter:{title:"Contacts",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Animating Tab Strip",permalink:"/doodle-tutorials/docs/tabstrip"},next:{title:"Calculator",permalink:"/doodle-tutorials/docs/calculator"}},d={},h=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"Async Assets",id:"async-assets",level:3},{value:"Theming",id:"theming",level:3},{value:"Routing",id:"routing",level:3},{value:"Responsive Layout",id:"responsive-layout",level:3},{value:"Main Views",id:"main-views",level:2},{value:"Header",id:"header",level:3},{value:"FilterBox",id:"filterbox",level:4},{value:"Contact List",id:"contact-list",level:3},{value:"Custom Table Behavior",id:"custom-table-behavior",level:4},{value:"Contact Creation",id:"contact-creation",level:3},{value:"Contact View",id:"contact-view",level:3},{value:"Contact Editing",id:"contact-editing",level:3}],u={toc:h};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"contacts-tutorial"},(0,i.kt)("a",{parentName:"h1",href:"https://github.com/nacular/doodle-tutorials/tree/master/Contacts"},"Contacts")," Tutorial"),(0,i.kt)("p",null,"This tutorial shows how you might build a simple app to track a list of contacts, each with a name and phone number. It is inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://phonebook-pi.vercel.app/"},"phonebook-pi.vercel.app"),", which\nwas built using React."),(0,i.kt)("p",null,"The app is multiplatform and is initialized with different dependencies based on the hosting situation.\nFor example, the one embedded in these docs does not support deep linking, as the router used is a memory only implementation.\nThe full screen, Web version does support deep links though. This works seamlessly, as the app itself is unaware of the implementation\ndetails of its dependencies."),(0,i.kt)(l.B,{functionName:"contacts",height:"700",mdxType:"DoodleCodeBlock"}),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"You can also see the full-screen app ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle-tutorials/contacts"},"here"),".")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"project-setup"},"Project Setup"),(0,i.kt)("p",null,"This app (like the others in this tutorial) is created as a multi-platform library, with a multiplatform launcher that depends on it.\nThis is not necessary to use Doodle. You could create a single multiplatform build with the common parts of your app\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"commonMain")," etc.. This setup is used here because the app are also launched by an app within ",(0,i.kt)("inlineCode",{parentName:"p"},"DocApps")," when embedding it\nlike below. Therefore, we need a pure library for the app. This is why there is an app and a runner."),(0,i.kt)("mermaid",{value:" classDiagram\n      Contacts      <|-- ContactsRunner\n      Contacts      <|-- DocApps\n      ContactsRunner: commonMain.resources\n      ContactsRunner: jvmMain.main\n      ContactsRunner: jsMain.main\n      DocApps       : main\n      Contacts      : commonMain\n      Contacts      : jvmMain\n      Contacts      : jsMain"}),(0,i.kt)(o.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"app",label:"Contacts",mdxType:"TabItem"},(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/build.gradle.kts"},(0,i.kt)("strong",{parentName:"a"},"build.gradle.kts"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="build.gradle.kts"',title:'"build.gradle.kts"'},'plugins {\n    kotlin("multiplatform"       )\n    kotlin("plugin.serialization")\n}\n\nkotlin {\n    jsTargets ()\n    jvmTargets()\n\n    val kodeinVersion       : String by project\n    val doodleVersion       : String by project\n    val coroutinesVersion   : String by project\n    val serializationVersion: String by project\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(kotlin("stdlib-common"))\n                api("org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutinesVersion")\n                api("org.jetbrains.kotlinx:kotlinx-serialization-json:$serializationVersion")\n                api("org.kodein.di:kodein-di:$kodeinVersion")\n\n                api("io.nacular.doodle:core:$doodleVersion"    )\n                api("io.nacular.doodle:controls:$doodleVersion")\n                api("io.nacular.doodle:themes:$doodleVersion")\n                api("io.nacular.doodle:animation:$doodleVersion")\n\n                api(project(":Modal"))\n            }\n        }\n    }\n}\n'))),(0,i.kt)(s.Z,{value:"runner",label:"ContactsRunner",mdxType:"TabItem"},(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/ContactsRunner/build.gradle.kts"},(0,i.kt)("strong",{parentName:"a"},"build.gradle.kts"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="build.gradle.kts"',title:'"build.gradle.kts"'},'plugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    js().browser()\n\n    jvm {\n        withJava()\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = "11"\n            }\n        }\n    }\n\n    val doodleVersion: String by project\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(project(":Contacts"))\n            }\n        }\n\n        val jsMain by getting {\n            dependencies {\n                implementation("io.nacular.doodle:browser:$doodleVersion")\n            }\n        }\n\n        val jvmMain by getting {\n            dependencies {\n                val osName = System.getProperty("os.name")\n                val targetOs = when {\n                    osName == "Mac OS X"       -> "macos"\n                    osName.startsWith("Win"  ) -> "windows"\n                    osName.startsWith("Linux") -> "linux"\n                    else                       -> error("Unsupported OS: $osName")\n                }\n\n                val osArch = System.getProperty("os.arch")\n                val targetArch = when (osArch) {\n                    "x86_64", "amd64" -> "x64"\n                    "aarch64"         -> "arm64"\n                    else              -> error("Unsupported arch: $osArch")\n                }\n\n                val target = "${targetOs}-${targetArch}"\n\n                implementation("io.nacular.doodle:desktop-jvm-$target:$doodleVersion")\n            }\n        }\n    }\n}\n\napplication {\n    mainClass.set("MainKt")\n}\n')),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"The desktop application uses placeholder icons in some cases to work-around a known ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/JetBrains/skiko/issues/518"},"Skiko bug"),"\nrelated to SVG path data parsing.")))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"the-application"},"The Application"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactsApp.kt"},(0,i.kt)("inlineCode",{parentName:"a"},"ContactsApp"))," is the entry point into our application. This is where the general structure of our app is defined. Note that Doodle creates all apps\nvia constructor and passes their dependencies that way. This means the ContactsApp can begin work on setting up its views, layout, and routing\ndirectly in ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),"."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactsApp.kt#L19"},(0,i.kt)("strong",{parentName:"a"},"ContactsApp.kt"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactsApp.kt"',title:'"ContactsApp.kt"'},'class ContactsApp(/*...*/): Application {\n\n    // ...\n\n    init {\n        // Coroutine used to load assets\n        appScope.launch(uiDispatcher) {\n            val appAssets = assets()\n\n            themeManager.selected = theme // Install theme\n\n            header      = Header     (appAssets)\n            contactList = ContactList(appAssets)\n\n            // Register handlers for different routes\n            router[""                      ] = { _,_        -> /* Contact List     */ }\n            router["/add"                  ] = { _,_        -> /* Contact Creation */ }\n            router["/contact/([0-9]+)"     ] = { _, matches -> /* Contact          */ }\n            router["/contact/([0-9]+)/edit"] = { _, matches -> /* Contact Editing  */ }\n\n            display += header\n\n            // Happens after header is added to ensure view goes below create button\n            router.fireAction()\n\n            display += CreateButton(appAssets)\n\n            // Setup layout that manages how Header, CreateButton, and current View are positioned\n            display.layout = simpleLayout { container ->\n                // ...\n            }\n\n            display.fill(appAssets.background.paint)\n        }\n    }\n\n    // ...\n\n    override fun shutdown() { /* no-op */ }\n}\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Notice that ",(0,i.kt)("inlineCode",{parentName:"p"},"shutdown")," is a no-op, since we don't have any cleanup to do when the app closes.")),(0,i.kt)("h3",{id:"async-assets"},"Async Assets"),(0,i.kt)("p",null,"The app uses custom fonts and images, both of which require async loading via ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/drawing/FontLoader.kt#L38"},(0,i.kt)("inlineCode",{parentName:"a"},"FontLoader")),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/image/ImageLoader.kt#L6"},(0,i.kt)("inlineCode",{parentName:"a"},"ImageLoader")),". It is easiest to load these within\nthe app itself (instead of trying to load them in the launcher and injecting). We are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppConfig")," interface to hold these assets and many different\napp attributes. The ContactsApp therefore needs to create an instance of this config, which must happen asynchronously since it internally loads\nfonts and images. This is what the ",(0,i.kt)("inlineCode",{parentName:"p"},"assets")," factory does, and why the app needs a ",(0,i.kt)("inlineCode",{parentName:"p"},"CoroutineScope")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcher")," injected."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactsApp.kt"',title:'"ContactsApp.kt"'},"class ContactsApp(\n    // ...\n    assets      : suspend () -> AppConfig,\n    appScope    : CoroutineScope,\n    uiDispatcher: CoroutineDispatcher,\n    // ...\n): Application {\n    // ...\n    init {\n        appScope.launch(uiDispatcher) {\n            val appAssets = assets()\n            // ...\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"Our launcher creates the ",(0,i.kt)("inlineCode",{parentName:"p"},"appScope")," ahead of app creation and injects it, along with ",(0,i.kt)("inlineCode",{parentName:"p"},"Dispatchers.UI"),"\n(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Browser/src/jsMain/kotlin/io/nacular/doodle/coroutines/Dispatchers.kt#L8"},"web"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Desktop/src/jvmMain/kotlin/io/nacular/doodle/coroutines/Dispatchers.kt#L8"},"desktop"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="main.kt"',title:'"main.kt"'},"fun main() {\n    // ...\n    val appScope = CoroutineScope(SupervisorJob() + kotlinx.coroutines.Dispatchers.Default)\n\n    application (modules = listOf(\n        // ...\n    )) {\n        // load app\n        ContactsApp(\n            // ...\n            appScope     = appScope\n            uiDispatcher = Dispatchers.UI,\n            // ...\n        )\n    }\n}\n")),(0,i.kt)("h3",{id:"theming"},"Theming"),(0,i.kt)("p",null,"Like most apps, we will use Views that rely on ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/rendering/behaviors"},"Behaviors")," to control their look and\nfeel. This includes things like ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/ui_components/overview#textfield"},"TextField"),", ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/ui_components/overview#label"},"Label"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/controls/panels/ScrollPanel.kt#L52"},"ScrollPanel"),", and\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/buttons/HyperLink.kt#L9"},(0,i.kt)("inlineCode",{parentName:"a"},"HyperLink")),".\nTherefore, we need to either provide these behaviors directly to each View, or use a ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/themes"},"Theme")," that\nautomatically binds behaviors to them. The latter approach is much simpler."),(0,i.kt)("p",null,"In this case, we use the following behaviors by installing ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/applications#dependencies"},"Modules")," when initializing the app."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="main.kt"',title:'"main.kt"'},"fun main() {\n    // ...\n\n    application (modules = listOf(\n        // ...\n        basicLabelBehavior       (),\n        nativeTextFieldBehavior  (spellCheck = false),\n        nativeHyperLinkBehavior  (),\n        nativeScrollPanelBehavior(),\n        // ...\n    )) {\n        // load app\n        ContactsApp(\n            // ...\n            theme        = instance(), // automatically available b/c Behavior modules installed\n            themeManager = instance(), // automatically available b/c Behavior modules installed\n            // ...\n        )\n    }\n}\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Notice that we also install modules to get support for ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/rendering/text#fonts"},"fonts"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/rendering/images"},"images"),", ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/pointer_input/overview"},"pointer"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/keyboard"},"keyboard")," and others.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Behavior")," modules used can be consumed in our app via the ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/themes#dynamic-themes"},"DynamicTheme")," instance.\nThis theme picks up all registered behaviors and installs them to the View type they are supposed to bind to. We can therefore inject this\n",(0,i.kt)("inlineCode",{parentName:"p"},"Theme")," and a ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/themes#thememanager"},"ThemeManager")," into the app's constructor."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactsApp.kt"',title:'"ContactsApp.kt"'},"class ContactsApp(\n    // ...\n    theme       : DynamicTheme,\n    themeManager: ThemeManager,\n    // ...\n): Application {\n    // ...\n    init {\n        appScope.launch(uiDispatcher) {\n            // ...\n            themeManager.selected = theme // Install theme\n            // ...\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("h3",{id:"routing"},"Routing"),(0,i.kt)("p",null,"This app relies on navigation and routes to display various screens. The Web (full screen) version supports deep linking as a result. The mapping between\nvarious routes and handlers is established in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactsApp.kt#L19"},(0,i.kt)("inlineCode",{parentName:"a"},"ContactsApp")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactsApp.kt"',title:'"ContactsApp.kt"'},'class ContactsApp(\n    // ...\n    router: Router,\n    // ...\n): Application {\n    // ...\n    init {\n        appScope.launch(uiDispatcher) {\n            // ...\n\n            // Register handlers for different routes\n            router[""                      ] = { _,_        -> /* Contact List     */ }\n            router["/add"                  ] = { _,_        -> /* Contact Creation */ }\n            router["/contact/([0-9]+)"     ] = { _, matches -> /* Contact          */ }\n            router["/contact/([0-9]+)/edit"] = { _, matches -> /* Contact Editing  */ }\n\n            // ...\n        }\n    }\n\n    // ...\n}\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/Router.kt#L9"},(0,i.kt)("inlineCode",{parentName:"a"},"Router")),"\ninterface supports registration of handlers by regex strings. This allows for routes that contain variable data.")),(0,i.kt)("h3",{id:"responsive-layout"},"Responsive Layout"),(0,i.kt)("p",null,"The app has 3 top-level Views that are visible at all times. The ",(0,i.kt)("a",{parentName:"p",href:"#header"},"Header"),", main View, and Create Button. These are all placed within the\n",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/display"},"Display"),", and are positioned, sized according to the specified ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/positioning"},"Layout"),".\nThat layout looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactsApp.kt"',title:'"ContactsApp.kt"'},"class ContactsApp(\n    // ...\n    display: Display,\n    // ...\n): Application {\n    // ...\n    init {\n        appScope.launch(uiDispatcher) {\n            // ...\n\n            display.layout = object: Layout {\n                // Header needs to be sized based on its minimumSize, so this layout should respond to any changes to it.\n                override fun requiresLayout(\n                    child: Positionable,\n                    of   : PositionableContainer,\n                    old  : View.SizePreferences,\n                    new  : View.SizePreferences\n                ) = new.minimumSize != old.minimumSize\n\n                override fun layout(container: PositionableContainer) {\n                    val mainView = container.children[1]\n                    val button   = container.children[2]\n\n                    header.size     = Size(container.width, header.minimumSize.height)\n                    mainView.bounds = Rectangle(INSET, header.height, max(0.0, header.width - 2 * INSET), max(0.0, container.height - header.height))\n\n                    button.bounds = when {\n                        container.width > header.filterCenterAboveWidth -> Rectangle(container.width - appAssets.createButtonLargeSize.width - 20, (header.naturalHeight - appAssets.createButtonLargeSize.height) / 2, appAssets.createButtonLargeSize.width, appAssets.createButtonLargeSize.height)\n                        else                                            -> Rectangle(container.width - appAssets.createButtonSmallSize.width - 20, container.height - appAssets.createButtonSmallSize.height - 40,      appAssets.createButtonSmallSize.width, appAssets.createButtonSmallSize.height)\n                    }\n                }\n            }\n\n            // ...\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"The Header is placed at the top and allowed to resize based on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display"),"'s width. The header will update its ",(0,i.kt)("inlineCode",{parentName:"p"},"minimumSize")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"idealSize")," based\non its width, which in turn will trigger a re-layout (see ",(0,i.kt)("inlineCode",{parentName:"p"},"requiresLayout")," above). The main View is always seated below the Header and takes the\nremaining space within the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display"),"."),(0,i.kt)("p",null,"Notice that the Create Button is a floating View. It is aligned to the right of the Header when there is sufficient space, but pops down to the\nbottom-right when the app's width is below a threshold. The Header and other Views also adapt their internal layouts based on the app's width"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The Create Button needs to be above all other Views, so the app ensures it is added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display")," last.")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"main-views"},"Main Views"),(0,i.kt)("h3",{id:"header"},(0,i.kt)("a",{parentName:"h3",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/Header.kt#L35"},"Header")),(0,i.kt)("p",null,"The app's header (which is always visible) provides a way to ",(0,i.kt)("a",{parentName:"p",href:"#filterbox"},"filter")," the ",(0,i.kt)("a",{parentName:"p",href:"#contact-list"},"Contact List"),"\nand navigate back to it whenever the logo area is clicked. It also positions its contents in a way that allows the floating create button to sit along side them as though it is a child."),(0,i.kt)(l.B,{functionName:"contactsHeader",height:"200",mdxType:"DoodleCodeBlock"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Header.kt"',title:'"Header.kt"'},'class Header(/*...*/): View() {\n\n    /** Search box that filters which contacts are shown */\n    private inner class FilterBox: View() {\n        // ...\n    }\n\n            val naturalHeight          =  64.0\n    private val filterRightAboveWidth  = 672.0\n    private val filterCenterAboveWidth = 800.0\n    private val filterBox: FilterBox\n\n    val filterCentered: Boolean get() = width > filterCenterAboveWidth\n\n    var searchEnabled by observable(true) { _,new ->\n        filterBox.enabled = new\n    }\n\n    init {\n        children += Photo(assets.logo).apply { size = Size(40) }\n        children += Label("Phonebook").apply {\n            font            = assets.large\n            behavior        = CommonLabelBehavior(textMetrics)\n            acceptsThemes   = false\n            foregroundColor = assets.header\n        }\n        children += FilterBox().apply { size = Size(300, 45); font = assets.medium }.also { filterBox = it }\n\n        val filterNaturalWidth = 300.0\n\n        layout = Layout.simpleLayout { container ->\n            val logo   = container.children[0]\n            val label  = container.children[1]\n            val filter = container.children[2]\n\n            logo.position  = Point(2 * INSET, (naturalHeight - logo.height) / 2)\n            label.position = Point(logo.bounds.right + 10, logo.bounds.center.y - label.height / 2)\n\n            filter.bounds = when {\n                container.width > filterCenterAboveWidth -> Rectangle((container.width - filterNaturalWidth) / 2,        logo.bounds.center.y - filter.height / 2, filterNaturalWidth, filter.height)\n                container.width > filterRightAboveWidth  -> Rectangle( container.width - filterNaturalWidth - 2 * INSET, logo.bounds.center.y - filter.height / 2, filterNaturalWidth, filter.height)\n                else                                     -> Rectangle(logo.x, logo.bounds.bottom + INSET, max(0.0, container.width - 4 * INSET), filter.height)\n            }\n        }.then {\n            minimumSize = Size(width, max(0.0, filterBox.bounds.bottom + 8))\n            idealSize   = minimumSize\n        }\n\n        // Custom cursor when pointer in the "clickable" region\n        pointerMotionChanged += moved {\n            cursor = when {\n                it.inHotspot -> Pointer\n                else         -> null\n            }\n        }\n\n        // Show Contact list when "clickable" region clicked\n        pointerChanged += clicked {\n            if (it.inHotspot) {\n                navigator.showContactList()\n            }\n        }\n    }\n\n    private val PointerEvent.inHotspot get() = this@Header.toLocal(location, target).x < 220\n}\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The Header uses pointer tracking to update its Cursor and handle clicking within its hot spot.")),(0,i.kt)("h4",{id:"filterbox"},"FilterBox"),(0,i.kt)("p",null,"The FilterBox is a simple wrapper around a ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/ui_components/overview#textfield"},"TextField"),"\nthat adds some iconography, handles styling and manages the animations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'private inner class FilterBox: View() {\n\n    private var progress              by renderProperty(0f  )\n    private var animation: Animation? by observable    (null) { old,_ -> old?.cancel() }\n\n    private val searchIcon     = PathIcon<View>(path(assets.searchIcon), fill = assets.search, pathMetrics = pathMetrics)\n    private val searchIconSize = searchIcon.size(this)\n\n    val textField = TextField().apply {\n        placeHolder      = "Search"\n        borderVisible    = false\n        backgroundColor  = Transparent\n        placeHolderColor = assets.placeHolder\n        focusChanged    += { _,_,hasFocus ->\n            // animate progress based on focus state\n            animation = (animate (progress to if (hasFocus) 1f else 0f) using assets.slowTransition) {\n                progress = it\n            }\n        }\n    }\n\n    init {\n        cursor             = Text\n        clipCanvasToBounds = false\n\n        val clearButton = PathIconButton(pathData = assets.deleteIcon, pathMetrics = pathMetrics).apply {\n            size            = Size(22, 44)\n            cursor          = Pointer\n            visible         = textField.text.isNotBlank()\n            foregroundColor = assets.search\n            fired += {\n                textField.text = ""\n            }\n        }\n\n        textField.textChanged += { _,_,new ->\n            when {\n                new.isBlank() -> contacts.filter = null\n                else          -> contacts.filter = { it.name.contains(new, ignoreCase = true) }\n            }\n\n            clearButton.visible = new.isNotBlank()\n        }\n\n        children += textField\n        children += clearButton\n\n        layout = constrain(children[0], children[1]) { textField, clear ->\n            textField.left    = parent.left + searchIconSize.width + 2 * 20\n            textField.height  = parent.height\n            textField.right   = clear.left\n            textField.centerY = parent.centerY\n            clear.right       = parent.right - 20\n            clear.centerY     = parent.centerY\n        }\n\n        pointerChanged += clicked {\n            focusManager.requestFocus(textField)\n        }\n    }\n\n    override fun render(canvas: Canvas) {\n        when {\n            // draw shadow when animating (progress > 0)\n            progress > 0f -> canvas.outerShadow(horizontal = 0.0, vertical = 4.0 * progress, color = assets.shadow, blurRadius = 3.0 * progress) {\n                // interpolate color during animation\n                canvas.rect(bounds.atOrigin, radius = 8.0, color = interpolate(assets.searchSelected, assets.background, progress))\n            }\n            else          -> canvas.rect(bounds.atOrigin, radius = 8.0, color = assets.searchSelected)\n        }\n\n        searchIcon.render(this, canvas, at = Point(20.0, (height - searchIconSize.height) / 2))\n    }\n}\n')),(0,i.kt)("h3",{id:"contact-list"},(0,i.kt)("a",{parentName:"h3",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactList.kt#L35"},"Contact List")),(0,i.kt)("p",null,"This is the main view within the app. It displays the contacts in a ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/ui_components/overview#table"},"Table")," with\nthree columns: ",(0,i.kt)("em",{parentName:"p"},"Name"),", ",(0,i.kt)("em",{parentName:"p"},"Phone Number"),", and an untitled one to hold the edit/delete tool buttons. This View extends Doodle's\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/table/DynamicTable.kt#L65"},(0,i.kt)("inlineCode",{parentName:"a"},"DynamicTable")),",\nwhich means it responds automatically to change in its underlying model. This is precisely what we need since Contacts will be added, edited, and\ndeleted."),(0,i.kt)(l.B,{functionName:"contactList",height:"550",mdxType:"DoodleCodeBlock"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactList.kt"',title:'"ContactList.kt"'},'class ContactList(\n   // ...\n): DynamicTable<Contact, MutableListModel<Contact>>(contacts, SingleItemSelectionModel(), block = {\n    val alignment      : Constraints.() -> Unit          = // ...\n    val nameVisualizer : CellVisualizer<Contact, String> = // ...\n    val toolsVisualizer: CellVisualizer<Contact, Unit>   = // ...\n\n    column(Label("Name"        ), { name        }, nameVisualizer   ) { cellAlignment = alignment; headerAlignment = alignment                }\n    column(Label("Phone Number"), { phoneNumber }, TextVisualizer() ) { cellAlignment = alignment; headerAlignment = alignment                }\n    column(null,                                   toolsVisualizer  ) { cellAlignment = fill(Insets(top = 20.0, bottom = 20.0, right = 20.0)) }\n}) {\n    init {\n        // ...\n\n        // Controls how the table\'s columns resize\n        columnSizePolicy = object: ColumnSizePolicy {\n            override fun layout(width: Double, columns: List<Column>, startIndex: Int): Double {\n                columns[2].width = if (width > 672.0 - 2 * INSET) 100.0 else 0.0 // FIXME: factor out hard-coded width\n                columns[0].width = width / 2\n                columns[1].width = width - columns[0].width - columns[2].width\n\n                return width\n            }\n\n            override fun widthChanged(width: Double, columns: List<Column>, index: Int, to: Double) {\n                // no-op\n            }\n        }\n\n        behavior      = ContactListBehavior(assets, navigator)\n        acceptsThemes = false\n    }\n}\n\n// ...\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"ContactList uses a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/SelectionModel.kt#L117"},(0,i.kt)("inlineCode",{parentName:"a"},"SingleItemSelectionModel")),"\nto ensure that only one row can be highlighted at a time.")),(0,i.kt)("p",null,"The table's columns are defined (at construction time), and the sizing policy for their widths is specified in the ",(0,i.kt)("inlineCode",{parentName:"p"},"apply")," block.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Table"),"s are all strongly-typed, so this one can only store ",(0,i.kt)("inlineCode",{parentName:"p"},"Contact"),"s. Which means each column can derive its data from some component of\na ",(0,i.kt)("inlineCode",{parentName:"p"},"Contact"),". The first two columns rely on ",(0,i.kt)("inlineCode",{parentName:"p"},"Contact.name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Contact.phoneNumber")," respectively. But the last column takes no data in,\nsince it will simply show buttons that fire events."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"columnSizePolicy")," used sizes the columns so that they take up the entire table width and scale such that the 3rd one disappears when\nthe table is below a threshold."),(0,i.kt)("h4",{id:"custom-table-behavior"},(0,i.kt)("a",{parentName:"h4",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactListBehavior.kt#L29"},"Custom Table Behavior")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ContactList")," uses a custom ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Controls/src/commonMain/kotlin/io/nacular/doodle/controls/table/TableBehavior.kt#L135"},(0,i.kt)("inlineCode",{parentName:"a"},"TableBehavior")),"\nvia ",(0,i.kt)("inlineCode",{parentName:"p"},"ContactListBehavior"),". Doodle's ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/ui_components/overview#table"},"Table")," is very customizable, since it\ndelegates a lot of functionality to ",(0,i.kt)("inlineCode",{parentName:"p"},"TableBehavior"),". We use this fact to specify how the header and body cells look and are positioned, as well as\nthe way selection highlighting works."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactListBehavior.kt"',title:'"ContactListBehavior.kt"'},'class ContactListBehavior(private val assets: AppConfig, private val navigator: Navigator): TableBehavior<Contact>() {\n    private inner class ContactCell<T>(/*...*/): View() {\n        // Represents each cell in the table\'s body\n        // Navigates to ContactView on pointer press\n        // Adds/removes row selection (for highlighting) on pointer enter/exit\n    }\n\n    private val selectionChanged: SetObserver<Table<Contact, *>, Int> = { table,_,_ ->\n        // Repaint the Table to show selected rows\n        table.bodyDirty()\n    }\n\n    override fun install(view: Table<Contact, *>) {\n        view.selectionChanged += selectionChanged\n    }\n\n    override fun uninstall(view: Table<Contact, *>) {\n        view.selectionChanged -= selectionChanged\n    }\n\n    override val headerCellGenerator = object: AbstractTableBehavior.HeaderCellGenerator<Table<Contact, *>> {\n        override fun <A> invoke(table: Table<Contact, *>, column: Column<A>) = container {\n            // Column header cell with underline\n        }\n    }\n\n    override val headerPositioner = object: AbstractTableBehavior.HeaderPositioner<Table<Contact, *>> {\n        override fun invoke(table: Table<Contact, *>) = HeaderGeometry(0.0, TABLE_HEADER_HEIGHT)\n    }\n\n    // No overflow column will be in the Table\n    override val overflowColumnConfig: Nothing? = null\n\n    @Suppress("UNCHECKED_CAST")\n    override val cellGenerator: CellGenerator<Contact> = object: CellGenerator<Contact> {\n        override fun <A> invoke(table: Table<Contact, *>, column: Column<A>, cell: A, row: Int, itemGenerator: ItemVisualizer<A, IndexedItem>, current: View?): View = when (current) {\n            is ContactCell<*> -> (current as ContactCell<A>).apply { update(table, cell, row) }\n            else              -> ContactCell(table, column, cell, row, itemGenerator)\n        }\n    }\n\n    override val rowPositioner: RowPositioner<Contact> = object: RowPositioner<Contact> {\n        // Position rows like a vertical list\n        private val delegate = VerticalListPositioner(ROW_HEIGHT)\n\n        override fun rowBounds  (of: Table<Contact, *>, row: Contact, index: Int) = delegate.itemBounds (of.size,     of.insets, index)\n        override fun row        (of: Table<Contact, *>, at: Point               ) = delegate.itemFor    (of.size,     of.insets,  at  )\n        override fun minimumSize(of: Table<Contact, *>                          ) = delegate.minimumSize(of.numItems, of.insets       )\n    }\n\n    override fun renderBody(table: Table<Contact, *>, canvas: Canvas) {\n        canvas.rect(table.bounds.atOrigin, color = assets.background)\n\n        // Highlight selected rows\n        table.selection.map { it to table[it] }.forEach { (index, row) ->\n            row.onSuccess {\n                canvas.rect(rowPositioner.rowBounds(table, it, index).inset(Insets(top = 1.0)), assets.listHighlight)\n            }\n        }\n    }\n}\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Highlighting on pointer hover is handled by each cell in the Table. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactListBehavior.kt#L29"},(0,i.kt)("inlineCode",{parentName:"a"},"ContactCell")),"\nregisters Pointer/MotionListeners and sets its row un/selected accordingly. This then results in ",(0,i.kt)("inlineCode",{parentName:"p"},"ContactListBehavior")," redrawing the\nTable background and coloring the selected rows.")),(0,i.kt)("h3",{id:"contact-creation"},(0,i.kt)("a",{parentName:"h3",href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/CreateContactView.kt#L24"},"Contact Creation")),(0,i.kt)("p",null,"This View allows the user to create a new contact. It shows a preview of the avatar that will be used and takes text input for both the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"phoneNumber"),". This View uses child Views for these components, including a ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/ui_components/form"},"Form")," for the input fields."),(0,i.kt)(l.B,{functionName:"contactCreation",height:"550",mdxType:"DoodleCodeBlock"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="CreateContactView.kt"',title:'"CreateContactView.kt"'},'class CreateContactView(\n    // ...\n): View() {\n    private inner class DynamicAvatar(private val image: Image): Avatar(textMetrics, "") {\n        override fun render(canvas: Canvas) {\n            when {\n                name.isBlank() -> canvas.clip(Circle(radius = min(width, height) / 2, center = Point(width / 2, height / 2))) {\n                    canvas.image(image, destination = bounds.atOrigin)\n                }\n                else -> super.render(canvas)\n            }\n        }\n    }\n\n    init {\n        lateinit var name       : String\n        lateinit var phoneNumber: String\n\n        val label = Label("Create Contact").apply {\n            font    = assets.medium\n            height  = 28.0\n            fitText = setOf(Width)\n        }\n\n        val back   = buttons.back  (assets.backIcon)\n        val avatar = DynamicAvatar (assets.blankAvatar).apply { size = Size(176); font = assets.medium }\n        val button = buttons.create(assets.buttonBackground, assets.buttonForeground).apply {\n            font     = assets.small\n            enabled  = false\n            fired   += {\n                contacts += Contact(name, phoneNumber)\n                navigator.showContactList()\n            }\n        }\n\n        val spacer = view {\n            height = 64.0\n            render = {\n                line(Point(0.0, height / 2), Point(width, height / 2), stroke = Stroke(assets.outline))\n            }\n        }\n\n        val form = editForm(\n            assets          = assets,\n            button          = button,\n            pathMetrics     = pathMetrics,\n            nameChanged     = { avatar.name = it },\n            textFieldStyler = textFieldStyler\n        ) { name_, phone_ ->\n            name           = name_\n            phoneNumber    = phone_\n            button.enabled = true\n        }\n\n        children += listOf(label, back, avatar, spacer, form, button)\n\n        layout = constrain(label, back, avatar, spacer, form, button) { (label, back, avatar, spacer, form, button) ->\n            // ...\n        }.then {\n            idealSize = Size(spacer.width + 2 * INSET, button.bounds.bottom + INSET)\n        }\n    }\n\n    // Helper to use constrain with 6 items\n    private operator fun <T> List<T>.component6() = this[5]\n}\n')),(0,i.kt)("h3",{id:"contact-view"},"Contact View"),(0,i.kt)("p",null,"This View shows the details of a contact. It allows the user to edit or delete the contact. Editing jumps to the ",(0,i.kt)("a",{parentName:"p",href:"#contact-editing"},"Contact Editing"),"\nscreen."),(0,i.kt)(l.B,{functionName:"contactView",height:"550",mdxType:"DoodleCodeBlock"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ContactView.kt"',title:'"ContactView.kt"'},'class ContactView(/*...*/): ContactCommon(/*...*/) {\n    init {\n        edit.apply {\n            fired += {\n                // Show Contact edit when pressed\n                navigator.showContactEdit(super.contact)\n            }\n        }\n\n        val details = container {\n            this += Label("Contact Details").apply {\n                font    = assets.small\n                height  = 24.0\n                fitText = setOf(Width)\n            }\n            this += HyperLink(\n                url  = "tel:${contact.phoneNumber}",\n                text = contact.phoneNumber,\n                icon = PathIcon(path = path(assets.phoneIcon), pathMetrics = pathMetrics, fill = assets.phoneNumber),\n            ).apply {\n                font            = assets.small\n                acceptsThemes   = false\n                iconTextSpacing = INSET\n                behavior        = linkStyler(this, object: CommonTextButtonBehavior<HyperLink>(textMetrics) {\n                    override fun install(view: HyperLink) {\n                        super.install(view)\n                        val textSize = textMetrics.size(text, font)\n                        val iconSize = icon!!.size(view)\n\n                        // Ensure link\'s size includes icon and text\n                        size = Size(textPosition(view).x + textSize.width, max(iconSize.height, textSize.height))\n                    }\n\n                    override fun render(view: HyperLink, canvas: Canvas) {\n                        icon!!.render(view, canvas, at = iconPosition(view, icon = icon!!))\n\n                        // Styled text with phoneNumberLink color and link\'s font\n                        canvas.text(assets.phoneNumberLink.invoke { view.font(view.text) }, at = textPosition(view))\n                    }\n                }) as Behavior<Button>\n            }\n\n            render = {\n                rect(bounds.atOrigin.inset(0.5), radius = 12.0, stroke = Stroke(assets.outline))\n            }\n\n            layout = constrain(children[0], children[1]) { label, link ->\n                label.top  = parent.top   + INSET\n                label.left = parent.left  + INSET\n                link.top   = label.bottom + INSET\n                link.left  = label.left\n            }\n        }\n\n        setDetail(details)\n\n        layout = simpleLayout { layoutCommonItems() }.then {\n            idealSize = Size(spacer.width + 2 * INSET, details.bounds.bottom + INSET)\n        }\n    }\n}\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"This view uses a customized HyperLink that contains an icon. HyperLinks are Buttons whose behaviors can be modified. In this case, we want the link\nto behave like a normal link, but fully customize the rendering. This is why we need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"linkStyler"),", which is a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Themes/src/commonMain/kotlin/io/nacular/doodle/theme/native/NativeHyperLinkBehavior.kt#L7"},(0,i.kt)("inlineCode",{parentName:"a"},"NativeHyperLinkStyler")),".")),(0,i.kt)("h3",{id:"contact-editing"},"Contact Editing"),(0,i.kt)("p",null,"Contacts are edited using this View. It is fairly similar to the CreateContactView, in that it displays the contact's avatar, ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"phoneNumber"),",\nand presents a form to modify them. It also has a delete button to remove the Contact. This View shares a lot of structure with ",(0,i.kt)("inlineCode",{parentName:"p"},"ContactView")," that\nis placed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ContactCommon")," base class."),(0,i.kt)(l.B,{functionName:"contactEditing",height:"620",mdxType:"DoodleCodeBlock"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="EditContactView.kt"',title:'"EditContactView.kt"'},"class EditContactView(\n    // ...\n): ContactCommon(\n    // ...\n) {\n    init {\n        lateinit var newName       : String\n        lateinit var newPhoneNumber: String\n\n        edit.apply {\n            enabled = false\n            fired += {\n                // tries to edit its contact\n                contacts.edit(super.contact) {\n                    name        = newName\n                    phoneNumber = newPhoneNumber\n                }.onSuccess {\n                    super.contact = it // updates its contact to the newly edited one\n                }\n\n                enabled = false\n            }\n        }\n\n        val form = editForm(super.contact.name, super.contact.phoneNumber, assets, textFieldStyler, pathMetrics, edit) { name, phone ->\n            // called whenever the Form becomes valid\n            newName        = name\n            newPhoneNumber = phone\n            edit.enabled   = name != super.contact.name || phone != super.contact.phoneNumber\n        }\n\n        setDetail(form) // super class utility for specifying details view\n\n        layout = simpleLayout {\n            layoutCommonItems() // super class utility\n\n            edit.position = Point(form.x, form.bounds.bottom + 2 * INSET)\n        }.then {\n            idealSize = Size(spacer.width + 2 * INSET, edit.bounds.bottom + INSET)\n        }\n    }\n}\n")))}m.isMDXComponent=!0}}]);