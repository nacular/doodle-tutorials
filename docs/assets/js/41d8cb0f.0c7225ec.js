"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5375],{2659:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>x,frontMatter:()=>h,metadata:()=>t,sourceTree:()=>m,toc:()=>v});const t=JSON.parse('{"id":"photos","title":"Photos","description":"Photos Tutorial","source":"@site/docs/photos.mdx","sourceDirName":".","slug":"/photos","permalink":"/doodle-tutorials/docs/photos","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Photos","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Todo","permalink":"/doodle-tutorials/docs/todo"},"next":{"title":"Photo Stream","permalink":"/doodle-tutorials/docs/photostream"}}');var i=o(4848),a=o(8453),s=(o(4865),o(9365),o(854)),r=o(9053),l=o(7020);const d='@file:OptIn(ExperimentalWasmDsl::class)\n\nimport org.jetbrains.kotlin.gradle.targets.js.dsl.ExperimentalWasmDsl\n\n//sampleStart\nplugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    js     { browser { binaries.executable() } } // Web     (JS  ) executable\n    wasmJs { browser { binaries.executable()     // Web     (WASM) executable\n        applyBinaryen {}                         // Binary size optimization\n    } }\n    jvm    {                                     // Desktop (JVM ) executable\n        compilations.all {\n            kotlinOptions { jvmTarget = "11" }   // JVM 11 is needed for Desktop\n        }\n        withJava()\n    }\n\n    sourceSets {\n        // Source set for all platforms\n        commonMain.dependencies {\n            api(libs.coroutines.core) // async photo loading\n\n            api(libs.doodle.themes   )\n            api(libs.doodle.controls )\n            api(libs.doodle.animation)\n        }\n\n        // Web (JS) platform source set\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        // Web (WASM) platform source set\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.doodle.browser)\n            }\n        }\n\n        // Desktop (JVM) platform source set\n        jvmMain.dependencies {\n            // helper to derive OS/architecture pair\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n    }\n}\n\n// Desktop entry point\napplication {\n    mainClass.set("io.nacular.doodle.examples.MainKt")\n}\n//sampleEnd\n\n// could be moved to buildSrc, but kept here for clarity\nfun osTarget(): String {\n    val osName = System.getProperty("os.name")\n    val targetOs = when {\n        osName == "Mac OS X"       -> "macos"\n        osName.startsWith("Win"  ) -> "windows"\n        osName.startsWith("Linux") -> "linux"\n        else                       -> error("Unsupported OS: $osName")\n    }\n\n    val targetArch = when (val osArch = System.getProperty("os.arch")) {\n        "x86_64", "amd64" -> "x64"\n        "aarch64"         -> "arm64"\n        else              -> error("Unsupported arch: $osArch")\n    }\n\n    return "${targetOs}-${targetArch}"\n}',c='package io.nacular.doodle.examples\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.AnimatorImpl\nimport io.nacular.doodle.application.Modules.Companion.DragDropModule\nimport io.nacular.doodle.application.Modules.Companion.FocusModule\nimport io.nacular.doodle.application.Modules.Companion.ImageModule\nimport io.nacular.doodle.application.Modules.Companion.KeyboardModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicCircularProgressIndicatorBehavior\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicLabelBehavior\nimport io.nacular.doodle.theme.basic.BasicTheme.Companion.basicMutableSpinButtonBehavior\nimport io.nacular.doodle.theme.native.NativeTheme.Companion.nativeTextFieldBehavior\nimport org.kodein.di.DI.Module\nimport org.kodein.di.bindSingleton\nimport org.kodein.di.instance\n\n/**\n * Creates a [PhotosApp]\n */\n//sampleStart\nfun main() {\n    application(modules = listOf(\n        FocusModule,\n        ImageModule,\n        KeyboardModule,\n        DragDropModule,\n        basicLabelBehavior(),\n        nativeTextFieldBehavior(spellCheck = false),\n        basicMutableSpinButtonBehavior(),\n        basicCircularProgressIndicatorBehavior(thickness = 18.0),\n        Module(name = "AppModule") {\n            bindSingleton<Animator> { AnimatorImpl(instance(), instance()) }\n        }\n    )) {\n        // load app\n        PhotosApp(\n            theme        = instance(),\n            images       = instance(),\n            display      = instance(),\n            animate      = instance(),\n            themeManager = instance(),\n            focusManager = instance()\n        )\n    }\n}\n//sampleEnd',h={title:"Photos",hide_title:!0},p=void 0,u={},m=(0,l.a)([{label:"src",children:[{label:"commonMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jsMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jvmMain",children:[{label:"kotlin"}]},{label:"wasmJsMain",children:[{label:"kotlin"},{label:"resources"}]}]},{label:"build.gradle.kts"}]),v=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"Drag-drop Support",id:"drag-drop-support",level:2},{value:"Importing An Image",id:"importing-an-image",level:2},{value:"Using Gestures",id:"using-gestures",level:2},{value:"Capturing Initial Gesture State",id:"capturing-initial-gesture-state",level:4},{value:"Handling Gesture Updates",id:"handling-gesture-updates",level:4}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h4:"h4",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("h1",{children:(0,i.jsx)("a",{class:"inline-github-link",href:"https://github.com/nacular/doodle-tutorials/tree/master/Photos",target:"_blank",children:"Photos Tutorial"})}),"\n",(0,i.jsx)(n.p,{children:"We will build a simple photo app that lets you view and manipulate images using a pointer or multi-touch. Images will be added to the app via drag-drop. You can then move, size, and rotate them with a mouse, pointer, touch, or via an info overlay."}),"\n",(0,i.jsx)(n.p,{children:"Here is the end result."}),"\n",(0,i.jsx)(r.I,{function:"photos",height:"700"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can also see the full-screen app here: ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/photos",children:"JavaScript"}),", ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/photos_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,i.jsx)(n.p,{children:"The app will use a Kotlin Multiplatform setup, which means we can run it on a range of targets supported by Doodle. The directory structure follows a fairly common layout, with common classes and resources in one source set and platform-specific items in their own."}),"\n","\n",(0,i.jsx)(n.admonition,{title:"Directory Layout",type:"info",children:(0,i.jsxs)(l.k,{items:m,defaultExpandedItems:["src","src/commonMain"],defaultSelectedItem:"src",children:[(0,i.jsxs)("div",{value:"src",children:[(0,i.jsxs)(n.p,{children:["All source code and resources are located under the ",(0,i.jsx)(n.code,{children:"src"})," directory."]}),(0,i.jsxs)(n.p,{children:["The application logic itself is located in the common source set (",(0,i.jsx)(n.code,{children:"src/commonMain"}),"), which means it is entirely reused for each platform. In fact, the same app is used unchanged (just targeting JS) within this documentation."]})]}),(0,i.jsx)("div",{value:"src/commonMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources for that are usable for platforms are stored in ",(0,i.jsx)(n.code,{children:"commonMain"}),". This app is designed to work on all platforms, so our app code and all logic is found under this directory."]})}),(0,i.jsxs)("div",{value:"src/commonMain/kotlin",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"kotlin"})," directory is where all code for a platform resides. In this case, we have all the classes for our app including ",(0,i.jsx)(n.code,{children:"PhotosApp"}),", ",(0,i.jsx)(n.code,{children:"GestureRecognizer"})," and ",(0,i.jsx)(n.code,{children:"Utils"}),"."]}),(0,i.jsx)(n.p,{children:"All of these classes are platform agnostic and used by all targets. This makes our app work on any target Doodle supports."})]}),(0,i.jsxs)("div",{value:"src/commonMain/resources",children:[(0,i.jsx)(n.p,{children:"An app can have resources like fonts, images, etc. that it loads at runtime. This directory contains these resources."}),(0,i.jsx)(n.p,{children:"In our case, we will be loading 2 default images we store here."})]}),(0,i.jsx)("div",{value:"src/jsMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Web (JS) target are stored in ",(0,i.jsx)(n.code,{children:"jsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,i.jsx)("div",{value:"src/jsMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function."]})}),(0,i.jsx)("div",{value:"src/jsMain/resources",children:(0,i.jsxs)(n.p,{children:["Holds the ",(0,i.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (JS) target."]})}),(0,i.jsx)("div",{value:"src/jvmMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Desktop (JVM) target are stored in ",(0,i.jsx)(n.code,{children:"jvmMain"}),"."]})}),(0,i.jsx)("div",{value:"src/jvmMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Desktop launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Web (WASM) target are stored in ",(0,i.jsx)(n.code,{children:"wasmJsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain/resources",children:(0,i.jsxs)(n.p,{children:["Holds the ",(0,i.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (WASM) target."]})}),(0,i.jsx)("div",{value:"build.gradle.kts",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"build.gradle.kts"})," file defines how the app is configured and all its dependencies. The Photos app uses a multi-platform configuration so it can run on all Doodle supported targets."]})})]})}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps are built using gradle like other Kotlin apps. The build is controlled by the ",(0,i.jsx)(n.code,{children:"build.gradle.kts"})," script in the root of the ",(0,i.jsx)(n.code,{children:"Photos"})," directory."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"build.gradle.kts"})}),"\n",(0,i.jsx)(s.v,{children:d}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The gradle build uses ",(0,i.jsx)(n.a,{href:"https://docs.gradle.org/current/userguide/version_catalogs.html",children:"gradle version catalogs"}),"; see ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file for library info."]})}),"\n",(0,i.jsx)(n.h2,{id:"the-application",children:"The Application"}),"\n",(0,i.jsxs)(n.p,{children:["All Doodle apps must implement the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:(0,i.jsx)(n.code,{children:"Application"})})," interface. The framework will then initialize our app via the constructor."]}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps can be ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. Use the ",(0,i.jsx)(n.code,{children:"application"})," function in a platform source-set (i.e. ",(0,i.jsx)(n.code,{children:"jsMain"}),", ",(0,i.jsx)(n.code,{children:"jvmMain"}),", etc.) to launch top-level apps. It takes a list of modules to load and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,i.jsx)(n.code,{children:"instance"}),", ",(0,i.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,i.jsx)(n.p,{children:"The app's structure is fairly simple. It has a main Container that holds the images and supports drag-drop, and a panel with controls for manipulating a selected image."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Photos/src/commonMain/kotlin/io/nacular/doodle/examples/PhotosApp.kt#L11",children:(0,i.jsx)(n.strong,{children:"PhotosApp.kt"})})}),"\n",(0,i.jsx)(s.v,{children:'\nclass PhotosApp(/*...*/): Application {\n  init {\n      // ...\n\n      val panelToggle                 // Button used to show/hide the panel\n      val panel                       // Has controls for manipulating images\n      val mainContainer = container { // container that holds images\n          // ...\n\n          dropReceiver = object: DropReceiver {\n              // support drag-drop importing\n          }\n\n          GlobalScope.launch {\n              listOf("tetons.jpg", "earth.jpg").forEachIndexed { index, file ->\n                  // load default images\n              }\n          }\n      }\n\n      display += listOf(mainContainer, panel, panelToggle)\n\n      // ...\n  }\n\n  override fun shutdown() {}\n}\n'}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,i.jsx)(s.v,{children:c}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Normally this would just be your ",(0,i.jsx)(n.code,{children:"main"})," function. But ",(0,i.jsx)(n.code,{children:"main"})," would prevent the app from being used as a library. Which is what happens to allow both an embedded (in the docs) and full-screen version."]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"application"})," function launches apps. It takes a list of modules, and a lambda that builds the\napp. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via\n",(0,i.jsx)(n.code,{children:"instance"}),", ",(0,i.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we have included several modules for our app. This includes one for focus, keyboard, drag-drop and several for various View ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/behaviors",children:(0,i.jsx)(n.code,{children:"Behaviors"})})," (i.e. ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/browser/io.nacular.doodle.theme.native/-native-theme/-companion/native-text-field-behavior.html",children:(0,i.jsx)(n.code,{children:"nativeTextFieldBehavior()"})}),") which loads the native behavior for TextFields. We also define some bindings directly in a new module. These are items with no built-in module, or items that only exist in our app code."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Check out Kodein to learn more about how it handles dependency injection."})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"application"})," function also takes an optional HTML element within which the app will be hosted. The app will be hosted in ",(0,i.jsx)(n.code,{children:"document.body"})," if you do not specify an element."]}),"\n",(0,i.jsx)(n.p,{children:"App launching is the only part of our code that is platform-specific; since it is the only time we might care about an HTML element. It also helps support embedding apps into non-Doodle contexts."}),"\n",(0,i.jsx)(n.h2,{id:"drag-drop-support",children:"Drag-drop Support"}),"\n",(0,i.jsxs)(n.p,{children:["Drag-drop support requires the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/dragdrop",children:(0,i.jsx)(n.code,{children:"DragDropModule"})})," to work. It then requires setting up drag/drop recognizers on the source/target Views. We created the ",(0,i.jsx)(n.code,{children:"mainContainer"})," for this. You can see that the ",(0,i.jsx)(n.code,{children:"dropReceiver"})," property is set to a ",(0,i.jsx)(n.code,{children:"DropReceiver"})," that controls how the ",(0,i.jsx)(n.code,{children:"mainContainer"})," handles drop events."]}),"\n",(0,i.jsx)(s.v,{children:'\nclass PhotosApp(/*...*/ private val images: ImageLoader /*...*/): Application {\n  init {\n      // ...\n      val mainContainer = container {\n          // ...\n\n          dropReceiver = object: DropReceiver {\n              private  val allowedFileTypes                    = Files(ImageType("jpg"), ImageType("jpeg"), ImageType("png"))\n              override val active                              = true\n              private  fun allowed          (event: DropEvent) = allowedFileTypes in event.bundle\n              override fun dropEnter        (event: DropEvent) = allowed(event)\n              override fun dropOver         (event: DropEvent) = allowed(event)\n              override fun dropActionChanged(event: DropEvent) = allowed(event)\n              override fun drop             (event: DropEvent) = event.bundle[allowedFileTypes]?.let { files ->\n                  val photos = files.map { GlobalScope.async { images.load(it)?.let { FixedAspectPhoto(it) } } }\n\n                  GlobalScope.launch {\n                      photos.mapNotNull { it.await() }.forEach { photo ->\n                          import(photo, event.location)\n                      }\n                  }\n                  true\n              } ?: false\n          }\n      }\n  }\n\n  // ...\n}\n'}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"DropReceiver"})," specifies the supported file-types (jpg, jpeg, and png). It then checks that any drop event contains valid files before accepting it. The ",(0,i.jsx)(n.code,{children:"drop(event: DropEvent)"})," method is called when the user attempts the final drop. Here, the receiver fetches all the allowed files in the bundle, and tries to load and import each one. Notice that the receiver converts raw Image returned by ",(0,i.jsx)(n.code,{children:"ImageLoader"})," into a ",(0,i.jsx)(n.code,{children:"FixedAspectPhoto"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"importing-an-image",children:"Importing An Image"}),"\n",(0,i.jsxs)(n.p,{children:["We import images using a local ",(0,i.jsx)(n.code,{children:"import"})," function inside the ",(0,i.jsx)(n.code,{children:"mainContainer"})," creation block. This simplifies access to local state. The ",(0,i.jsx)(n.code,{children:"import"})," function takes a photo, which is a ",(0,i.jsx)(n.code,{children:"View"}),", and a location to place it."]}),"\n",(0,i.jsx)(s.v,{children:"\nval import = { photo: View, location: Point ->\n\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["Import resizes and centers the photo at the given point. It center-rotates it between -15\xb0 and 15\xb0. Finally, a listener is added to the ",(0,i.jsx)(n.code,{children:"pressed"})," pointer event. This moves the photo to the foreground and updates the panel."]}),"\n",(0,i.jsx)(s.v,{children:"\nphoto.width           = 400.0\nphoto.position        = location - Point(photo.width / 2, photo.height / 2)\nphoto.transform       = Identity.rotate(location, (Random.nextFloat() * 30 - 15) * degrees)\nphoto.pointerChanged += pressed {\n  children.move(photo, to = children.size - 1)\n  panel.setPhoto(photo)\n}\n"}),"\n",(0,i.jsx)(n.h2,{id:"using-gestures",children:"Using Gestures"}),"\n",(0,i.jsx)(n.p,{children:"Import also registers a custom gesture listener to support multi-touch scaling and rotations."}),"\n",(0,i.jsx)(s.v,{children:"\nGestureRecognizer(photo).changed += object: GestureListener<GestureEvent> {\n  // ...\n\n  override fun started(event: GestureEvent) {\n      // capture initial state\n      event.consume()\n  }\n\n  override fun changed(event: GestureEvent) {\n      // 1) calculate rotation angle\n      // 2) update photo transform to include rotation\n      // 3) update photo bounds based on scaling\n      event.consume()\n  }\n\n  override fun ended(event: GestureEvent) {\n      // simply consume event\n      event.consume()\n  }\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GestureRecognizer"})," takes a ",(0,i.jsx)(n.code,{children:"View"})," and emits events whenever it detects motion from 2 or more pointers in that ",(0,i.jsx)(n.code,{children:"View"}),". It also calculates a scale value by comparing the distance between the selected pointers over time."]}),"\n",(0,i.jsxs)(n.p,{children:["We register a listener that uses the events to update the photo's ",(0,i.jsx)(n.code,{children:"transform"})," and ",(0,i.jsx)(n.code,{children:"bounds"}),". The listener also consumes events to avoid them making it to subsequent pointer listeners (the ",(0,i.jsx)(n.code,{children:"Resizer"})," used for single pointer manipulation in this case)."]}),"\n",(0,i.jsx)(n.h4,{id:"capturing-initial-gesture-state",children:"Capturing Initial Gesture State"}),"\n",(0,i.jsxs)(n.p,{children:["We record the state of our photo, and the pointers provided by the ",(0,i.jsx)(n.code,{children:"GestureRecognizer"})," on the ",(0,i.jsx)(n.code,{children:"started"})," event. Notice that ",(0,i.jsx)(n.code,{children:"GestureRecognizer"})," provides locations in the photo's local coordinate. This makes sense for a general-purpose utility and matches the way Doodle reports pointer events. We use these values to modify the photo's bounds though, which is defined in its parent's coordinates. So we map the points into the parent before our calculations."]}),"\n",(0,i.jsx)(s.v,{children:"\noverride fun started(event: GestureEvent) {\n  // Capture initial state to apply deltas with in `changed`\n  originalSize     = photo.size\n  originalCenter   = this@container.toLocal(event.center, photo)\n  originalVector   = event.initial[1].inParent(photo) - event.initial[0].inParent(photo)\n  originalPosition = photo.position\n  initialTransform = photo.transform\n\n  event.consume() // ensure event is consumed from Resizer\n}\n"}),"\n",(0,i.jsx)(n.h4,{id:"handling-gesture-updates",children:"Handling Gesture Updates"}),"\n",(0,i.jsxs)(n.p,{children:["The values recorded in ",(0,i.jsx)(n.code,{children:"started"})," are used--along with the new state--in the ",(0,i.jsx)(n.code,{children:"changed"})," event to update the selected photo."]}),"\n",(0,i.jsx)(s.v,{children:"\noverride fun changed(event: GestureEvent) {\n  val currentVector = event.current[1].inParent(photo) - event.current[0].inParent(photo)\n\n  // Angle between initial set of points and their current locations\n  val transformAngle = atan2(\n      originalVector.x * currentVector.y - originalVector.y * currentVector.x,\n      originalVector.x * currentVector.x + originalVector.y * currentVector.y\n  )\n\n  // Use transform for rotation\n  photo.transform = initialTransform.rotate(around = originalCenter, by = transformAngle)\n\n  // Update bounds instead of scale transformation\n  photo.bounds = Rectangle(\n          originalPosition - ((originalPosition - originalCenter) * (1 - event.scale)),\n          originalSize * event.scale)\n\n  event.consume() // ensure event is consumed from Resizer\n}\n"})]})}function x(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);