"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9763],{4008:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>x,contentTitle:()=>m,default:()=>v,frontMatter:()=>p,metadata:()=>o,sourceTree:()=>f,toc:()=>g});const o=JSON.parse('{"id":"calculator","title":"Calculator","description":"Calculator Tutorial","source":"@site/docs/calculator.mdx","sourceDirName":".","slug":"/calculator","permalink":"/doodle-tutorials/docs/calculator","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Calculator","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Contacts","permalink":"/doodle-tutorials/docs/contacts"},"next":{"title":"Todo","permalink":"/doodle-tutorials/docs/todo"}}');var i=t(4848),a=t(8453),r=(t(4865),t(9365),t(854)),l=t(9053),s=t(7020);const d='@file:OptIn(ExperimentalWasmDsl::class)\n\nimport org.jetbrains.kotlin.gradle.targets.js.dsl.ExperimentalWasmDsl\n\n//sampleStart\nplugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    js     { browser { binaries.executable() } } // Web     (JS  ) executable\n    wasmJs { browser { binaries.executable()     // Web     (WASM) executable\n        applyBinaryen {}                         // Binary size optimization\n    } }\n    jvm    {                                     // Desktop (JVM ) executable\n        compilations.all {\n            kotlinOptions { jvmTarget = "11" }   // JVM 11 is needed for Desktop\n        }\n        withJava()\n    }\n\n    sourceSets {\n        // Source set for all platforms\n        commonMain.dependencies {\n            api(libs.coroutines.core) // async resource loading (fonts, images, ...)\n            api(libs.doodle.controls)\n        }\n\n        // Web (JS) platform source set\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        // Web (WASM) platform source set\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.doodle.browser)\n            }\n        }\n\n        // Desktop (JVM) platform source set\n        jvmMain.dependencies {\n            // helper to derive OS/architecture pair\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n\n        // JVM tests source set\n        jvmTest.dependencies {\n            implementation(kotlin("test-junit"))\n            implementation(libs.bundles.test.libs)\n        }\n    }\n}\n\n// Desktop entry point\napplication {\n    mainClass.set("io.nacular.doodle.examples.MainKt")\n}\n//sampleEnd\n\n// could be moved to buildSrc, but kept here for clarity\nfun osTarget(): String {\n    val osName = System.getProperty("os.name")\n    val targetOs = when {\n        osName == "Mac OS X"       -> "macos"\n        osName.startsWith("Win"  ) -> "windows"\n        osName.startsWith("Linux") -> "linux"\n        else                       -> error("Unsupported OS: $osName")\n    }\n\n    val targetArch = when (val osArch = System.getProperty("os.arch")) {\n        "x86_64", "amd64" -> "x64"\n        "aarch64"         -> "arm64"\n        else              -> error("Unsupported arch: $osArch")\n    }\n\n    return "${targetOs}-${targetArch}"\n}',c="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.application.Modules.Companion.FontModule\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport org.kodein.di.instance\n\n/**\n * Creates a [CalculatorApp]\n */\n//sampleStart\nfun main() {\n    application(modules = listOf(FontModule, PointerModule)) {\n        // load app\n        CalculatorApp(\n            display         = instance(),\n            textMetrics     = instance(),\n            fonts           = instance(),\n            numberFormatter = NumberFormatterImpl()\n        )\n    }\n}\n//sampleEnd",u='package io.nacular.doodle.examples\n\nimport io.nacular.doodle.controls.buttons.Button\nimport io.nacular.doodle.controls.buttons.ButtonGroup\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.buttons.ToggleButton\nimport io.nacular.doodle.controls.panels.GridPanel\nimport io.nacular.doodle.core.Layout\nimport io.nacular.doodle.core.PositionableContainer\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.AffineTransform.Companion.Identity\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Darkgray\nimport io.nacular.doodle.drawing.Color.Companion.Lightgray\nimport io.nacular.doodle.drawing.Color.Companion.Orange\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.darker\nimport io.nacular.doodle.drawing.lighter\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.drawing.text\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.system.Cursor.Companion.Pointer\nimport io.nacular.doodle.utils.roundToNearest\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\nimport kotlin.js.JsName\nimport kotlin.math.pow\n\n/**\n * Simple calculator with basic math operations.\n *\n * @property fonts           used to find fonts\n * @param    appScope        used to run coroutines\n * @property textMetrics     used to measure text\n * @property numberFormatter used to display number output\n */\nclass Calculator(\n    private val fonts          : FontLoader,\n                appScope       : CoroutineScope,\n    private val textMetrics    : TextMetrics,\n    private val numberFormatter: NumberFormatter\n): View() {\n    // region ================ Helper Classes ==================================\n\n    private inner class Output: View() {\n\n        // Default width when input starts at `0`\n        private val defaultWidth get() = textMetrics.width("0", font)\n\n        // Text inset from the left/right edge of the output\n        private val inset by lazy { (clear.width - defaultWidth) / 2 }\n\n        // Transform used to scale text down as it grows beyond window width\n        private var textTransform = Identity\n\n        /** Numeric value of the output */\n        var number = 0.0; set(new) {\n            field = new\n            text  = numberFormatter(number)\n        }\n\n        /** Text representation of [number] */\n        var text = "0"; set(new) {\n            field = new\n\n            val textWidth   = textMetrics.width(field, font)\n            val windowWidth = width - inset * 2\n\n            // use transform when text grows beyond window width\n            textTransform = when {\n                textWidth > windowWidth -> (windowWidth/textWidth).let { Identity.scale(x = it, y = it, around = Point(width / 2, height)) }\n                else                    -> Identity\n            }\n\n            rerender()\n        }\n\n        init {\n            foregroundColor = White\n        }\n\n        override fun render(canvas: Canvas) {\n            val textPosition = textMetrics.size(text, font).let {\n                val x = when {\n                    textTransform.isIdentity -> width - it.width - inset\n                    else                     -> (width - it.width) / 2\n                }\n\n                Point(x, height - it.height)\n            }\n\n            // scaling, if present, is applied to the canvas before text rendered\n            canvas.transform(textTransform) {\n                text(text, at = textPosition, font = font, color = foregroundColor ?: White)\n            }\n        }\n    }\n\n    inner class OperatorButton(text: String, background: Color = operatorColor, foreground: Color = White, private val method: Double.(Double) -> Double): ToggleButton(text) {\n        init {\n            configure(this, background, foreground)\n\n            fired += {\n                compute()\n\n                activeOperator = this\n            }\n        }\n\n        internal operator fun invoke(left: Double, right: Double) = method(left, right)\n    }\n\n    // endregion\n\n    // region ================ Colors ==================================\n\n    private val numberColor   = Darkgray.darker(0.5f)\n    private val operatorColor = Orange.lighter (0.1f)\n\n    // endregion\n\n    // region ================ Internal State ==================================\n\n    private var activeOperator: OperatorButton? = null; set(new) {\n        field = new\n\n        when (field) {\n            null -> {\n                div.selected  = false\n                times.selected = false\n                minus.selected = false\n                plus.selected  = false\n            }\n        }\n    }\n\n    private var reset             = true                    // indicates when to begin a new operand\n    private var negated           = false                   // tracks whether number is negative\n    private var leftValue         = null as Double?         // left-side operand\n    private var rightValue        = null as Double?         // right-side operand\n    private var decimalPlace      = 0                       // tracks decimal place for fractions\n    private var committedOperator = null as OperatorButton? // operator to be applied to left and right values\n\n    // endregion\n\n    // region ================ Visual Elements =================================\n\n    private val output = Output()\n\n    val result get() = output.number\n\n    val div   = OperatorButton("\xf7", method = Double::div  )\n    val times = OperatorButton("\xd7", method = Double::times)\n    val minus = OperatorButton("-", method = Double::minus)\n    val plus  = OperatorButton("+", method = Double::plus )\n\n    val clear = func("AC" ).apply {\n        fired += {\n            output.number = 0.0\n            clearInternalState()\n        }\n    }\n    val negate = func("+/-").apply {\n        fired += {\n            if (reset) { output.number = 0.0 }\n\n            reset   = false\n            negated = !negated\n\n            output.number *= -1\n        }\n    }\n\n    val percent = func("%").apply {\n        fired += {\n            output.number *= 0.01\n        }\n    }\n    val decimal = func(".", background = numberColor, foreground = White).apply {\n        fired += {\n            if (decimalPlace == 0) {\n                if (reset) { output.number = 0.0 }\n\n                reset        = false\n                output.text += "."   // bit of a hack/short-cut since the number formatter should be used\n                decimalPlace = 1\n            }\n        }\n    }\n\n    val equal = func("=", operatorColor, White).apply {\n        fired += {\n            compute()\n            clearInternalState()\n        }\n    }\n\n    @JsName("nine" ) val `9` = number(9)\n    @JsName("eight") val `8` = number(8)\n    @JsName("seven") val `7` = number(7)\n    @JsName("six"  ) val `6` = number(6)\n    @JsName("five" ) val `5` = number(5)\n    @JsName("four" ) val `4` = number(4)\n    @JsName("three") val `3` = number(3)\n    @JsName("two"  ) val `2` = number(2)\n    @JsName("one"  ) val `1` = number(1)\n    @JsName("zero" ) val `0` = number(0)\n\n    // endregion\n\n    // region ================ Button Helpers ==================================\n\n    private fun button(text: String, background: Color = operatorColor, foreground: Color = White) = configure(PushButton(text), background, foreground)\n    private fun func  (text: String, background: Color = Lightgray,     foreground: Color = Black) = button(text, background, foreground)\n    private fun number(number: Int                                                               ) = button("$number", background = numberColor).apply {\n        fired += {\n            committedOperator = activeOperator\n\n            val newDigit = (if (negated) -1 else 1) * number.toDouble()\n\n            output.number = when {\n                reset             -> number.toDouble()\n                decimalPlace == 0 -> output.number * 10 + newDigit\n                decimalPlace < 10 -> {\n                    val fraction = 1 / 10.0.pow(decimalPlace)\n\n                    (output.number + newDigit * fraction).roundToNearest(fraction).also { ++decimalPlace }\n                }\n                else              -> output.number\n            }\n\n            reset = false\n        }\n    }\n\n    private fun configure(button: Button, background: Color, foreground: Color) = button.apply {\n        size            = Size(60)\n        cursor          = Pointer\n        behavior        = CalcButtonBehavior(textMetrics)\n        foregroundColor = foreground\n        backgroundColor = background\n    }\n\n    // endregion\n\n    /**\n     * Computes the current value based on [leftValue], [rightValue], and [committedOperator].\n     */\n    private fun compute() {\n        when {\n            committedOperator != null -> rightValue = output.number\n            leftValue        == null  -> leftValue  = output.number\n        }\n\n        committedOperator?.let { operator ->\n            leftValue?.let { left ->\n                rightValue?.let { right ->\n                    operator(left, right).also {\n                        output.number = it\n                        leftValue     = it\n                        rightValue    = null\n                    }\n                    committedOperator = null\n                }\n            }\n        }\n\n        reset        = true\n        decimalPlace = 0\n    }\n\n    /**\n     * Resets all internal state, except [output].\n     */\n    private fun clearInternalState() {\n        reset             = true\n        negated           = false\n        leftValue         = null\n        rightValue        = null\n        decimalPlace      = 0\n        activeOperator    = null\n        committedOperator = null\n    }\n\n    /**\n     * Updates font for [output] and function buttons using different sizes and weights than the given [font].\n     */\n    private suspend fun loadFonts() {\n        font = fonts("Roboto-Regular.ttf") {\n            family = "Roboto"\n            weight = 400\n            size   = 32\n        }\n\n        font?.let { font ->\n            fonts("Roboto-Light.ttf") {\n                family = "Roboto"\n                size   = font.size - 5\n                weight = 100\n            }?.let { lightFont ->\n                output.font        = fonts(lightFont) { size = 72 }\n                clear.font         = lightFont\n                negate.font        = lightFont\n                percent.font = lightFont\n            }\n        }\n    }\n\n//sampleStart\n    init {\n        appScope.launch {\n            loadFonts()\n\n            ButtonGroup(allowDeselectAll = true, buttons = arrayOf(div, times, minus, plus))\n\n            val outputHeight  = 100.0\n            val buttonSpacing =  10.0\n\n            // Use GridPanel to hold all buttons\n            val gridPanel = GridPanel().apply {\n                add(clear, 0, 0); add(negate, 0, 1); add(percent, 0, 2); add(div,   0, 3)\n                add(`7`,   1, 0); add(`8`,    1, 1); add(`9`,     1, 2); add(times, 1, 3)\n                add(`4`,   2, 0); add(`5`,    2, 1); add(`6`,     2, 2); add(minus, 2, 3)\n                add(`1`,   3, 0); add(`2`,    3, 1); add(`3`,     3, 2); add(plus,  3, 3)\n                add(`0`,   4, 0,  columnSpan = 2  ); add(decimal, 4, 2); add(equal, 4, 3)\n\n                rowSpacing    = { buttonSpacing }\n                columnSpacing = { buttonSpacing }\n            }\n\n            // Add output and gridPanel to the Calculator view\n            children += listOf(output, gridPanel)\n\n            val insets = 10.0\n\n            // Place Output outside grid so the height can be more easily controlled\n            val constraints = constrain(output, gridPanel) { output, grid ->\n                output.top    eq insets\n                output.left   eq insets\n                output.right  eq parent.right - insets\n                output.height eq outputHeight\n\n                grid.top      eq output.bottom + buttonSpacing\n                grid.left     eq output.left\n                grid.right    eq output.right\n                grid.bottom   eq parent.bottom - insets\n            }\n\n            layout = object: Layout by constraints {\n                // Set total height to grid panel\'s ideal width and height, plus output and spacing\n                override fun idealSize(container: PositionableContainer, default: Size?) = gridPanel.idealSize?.let {\n                    Size(it.width + 2 * insets, it.height + outputHeight + buttonSpacing + 2 * insets)\n                }\n            }\n\n            // Force idealSize when gridPanel is laid out\n            gridPanel.sizePreferencesChanged += { _,_,new ->\n                idealSize = new.idealSize?.let { Size(it.width + 2 * insets, it.height + outputHeight + buttonSpacing + 2 * insets) }\n            }\n        }\n    }\n//sampleEnd\n\n    override fun render(canvas: Canvas) {\n        canvas.rect(bounds.atOrigin, radius = 40.0, color = Black)\n    }\n}',h="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.layout.constraints.constrain\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\n\n/**\n * Simple calculate app that places a [Calculator] at the center of the display.\n */\n//sampleStart\nclass CalculatorApp(\n    display        : Display,\n    textMetrics    : TextMetrics,\n    fonts          : FontLoader,\n    numberFormatter: NumberFormatter\n): Application {\n    init {\n        val appScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n\n        display += Calculator(fonts, appScope, textMetrics, numberFormatter).apply {\n            sizePreferencesChanged += { _,_,_ ->\n                display.relayout()\n            }\n        }\n\n        display.layout = constrain(display.children[0]) {\n            it.width  eq (display.children.firstOrNull()?.idealSize?.width  ?: 0.0)\n            it.height eq (display.children.firstOrNull()?.idealSize?.height ?: 0.0)\n            it.center eq parent.center\n        }\n    }\n\n    override fun shutdown() { /* no-op */ }\n}\n//sampleEnd",p={title:"Calculator",hide_title:!0},m=void 0,x={},f=(0,s.a)([{label:"src",children:[{label:"commonMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jsMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jvmMain",children:[{label:"kotlin"}]},{label:"jvmTest",children:[{label:"kotlin"}]},{label:"wasmJsMain",children:[{label:"kotlin"},{label:"resources"}]}]},{label:"build.gradle.kts"}]),g=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"App Launcher",id:"app-launcher",level:2},{value:"Calculator View",id:"calculator-view",level:2},{value:"More Dependencies",id:"more-dependencies",level:2},{value:"The Buttons",id:"the-buttons",level:2},{value:"Button Styling",id:"button-styling",level:2},{value:"Custom Hit Detection",id:"custom-hit-detection",level:2},{value:"Testing",id:"testing",level:2}];function b(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("h1",{children:(0,i.jsx)("a",{class:"inline-github-link",href:"https://github.com/nacular/doodle-tutorials/tree/master/Calculator",target:"_blank",children:"Calculator Tutorial"})}),"\n",(0,i.jsx)(n.p,{children:"Our goal is to build the following calculator app using Doodle. This is a simple calculator that only performs addition, subtraction, multiplication, and division. It also supports negative values, decimals, and has a convenience function for converting to a percentage."}),"\n",(0,i.jsx)(n.p,{children:"However, it does not have more advanced features, like parentheses, or other math operations. This means the implementation is simpler, and we can focus on the way Doodle is used instead of the complexity of the app itself. Play around with the calculator to get a feel for it."}),"\n",(0,i.jsx)(l.I,{function:"calculator",height:"500"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can also see the full-screen apps here: ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/calculator",children:"JavaScript"}),", ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/calculator_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,i.jsx)(n.p,{children:"The app will use a Kotlin Multiplatform setup, which means we can run it on a range of targets supported by Doodle. The directory structure follows a fairly common layout, with common classes and resources in one source set and platform-specific items in their own."}),"\n","\n",(0,i.jsx)(n.admonition,{title:"Directory Layout",type:"info",children:(0,i.jsxs)(s.k,{items:f,defaultExpandedItems:["src","src/commonMain"],defaultSelectedItem:"src",children:[(0,i.jsxs)("div",{value:"src",children:[(0,i.jsxs)(n.p,{children:["All source code and resources are located under the ",(0,i.jsx)(n.code,{children:"src"})," directory."]}),(0,i.jsxs)(n.p,{children:["The application logic itself is located in the common source set (",(0,i.jsx)(n.code,{children:"src/commonMain"}),"), which means it is entirely reused for each platform. In fact, the same app is used unchanged (just targeting JS) within this documentation."]})]}),(0,i.jsx)("div",{value:"src/commonMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources for that are usable for platforms are stored in ",(0,i.jsx)(n.code,{children:"commonMain"}),". This app is designed to work on all platforms, so our app code and all logic is found under this directory."]})}),(0,i.jsxs)("div",{value:"src/commonMain/kotlin",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"kotlin"})," directory is where all code for a platform resides. In this case, we have all the classes for our app including ",(0,i.jsx)(n.code,{children:"CalculatorApp"}),", ",(0,i.jsx)(n.code,{children:"Calculator"}),", ",(0,i.jsx)(n.code,{children:"CalculatorButtonBehavior"})," and ",(0,i.jsx)(n.code,{children:"NumberFormatter"}),"."]}),(0,i.jsx)(n.p,{children:"All of these classes are platform agnostic and used by all targets. This makes our app work on any target Doodle supports."})]}),(0,i.jsxs)("div",{value:"src/commonMain/resources",children:[(0,i.jsx)(n.p,{children:"An app can have resources like fonts, images, etc. that it loads at runtime. This directory contains these resources."}),(0,i.jsx)(n.p,{children:"In our case, we will be loading two fonts that we store here."})]}),(0,i.jsx)("div",{value:"src/jsMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Web (JS) target are stored in ",(0,i.jsx)(n.code,{children:"jsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,i.jsx)("div",{value:"src/jsMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function. The JS version uses a platform-specific ",(0,i.jsx)(n.code,{children:"NumberFormatter"})," that is based on ",(0,i.jsx)(n.code,{children:"Intl.NumberFormat"}),"."]})}),(0,i.jsx)("div",{value:"src/jsMain/resources",children:(0,i.jsxs)(n.p,{children:["Holds the ",(0,i.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (JS) target."]})}),(0,i.jsx)("div",{value:"src/jvmMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Desktop (JVM) target are stored in ",(0,i.jsx)(n.code,{children:"jvmMain"}),"."]})}),(0,i.jsx)("div",{value:"src/jvmMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Desktop launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function. This version uses a platform-specific ",(0,i.jsx)(n.code,{children:"NumberFormatter"})," that is based on ",(0,i.jsx)(n.code,{children:"java.text.NumberFormat"}),"."]})}),(0,i.jsx)("div",{value:"src/jvmTest",children:(0,i.jsxs)(n.p,{children:["Tests written for our ",(0,i.jsx)(n.code,{children:"Calculator"})," that will be run on the JVM. These tests are here instead of in ",(0,i.jsx)(n.code,{children:"commonTest"})," because they use Mockk, which only runs on the JVM."]})}),(0,i.jsx)("div",{value:"src/jvmTest/kotlin",children:(0,i.jsxs)(n.p,{children:["Tests written for our ",(0,i.jsx)(n.code,{children:"Calculator"})," that will be run on the JVM. These tests are here instead of in ",(0,i.jsx)(n.code,{children:"commonTest"})," because they use Mockk, which only runs on the JVM."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Web (WASM) target are stored in ",(0,i.jsx)(n.code,{children:"wasmJsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function. The WASM version uses a platform-specific ",(0,i.jsx)(n.code,{children:"NumberFormatter"})," that is based on ",(0,i.jsx)(n.code,{children:"Intl.NumberFormat"}),"."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain/resources",children:(0,i.jsxs)(n.p,{children:["Holds the ",(0,i.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (WASM) target."]})}),(0,i.jsx)("div",{value:"build.gradle.kts",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"build.gradle.kts"})," file defines how the app is configured and all its dependencies. The Calculator app uses a multi-platform configuration so it can run on all Doodle supported targets."]})})]})}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps are built using gradle like other Kotlin apps. The build is controlled by the ",(0,i.jsx)(n.code,{children:"build.gradle.kts"})," script in the root of the ",(0,i.jsx)(n.code,{children:"Calculator"})," directory."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"build.gradle.kts"})}),"\n",(0,i.jsx)(r.v,{children:d}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The gradle build uses ",(0,i.jsx)(n.a,{href:"https://docs.gradle.org/current/userguide/version_catalogs.html",children:"gradle version catalogs"}),"; see ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file for library info."]})}),"\n",(0,i.jsx)(n.h2,{id:"the-application",children:"The Application"}),"\n",(0,i.jsxs)(n.p,{children:["All Doodle apps must implement the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:(0,i.jsx)(n.code,{children:"Application"})})," interface. The constructor is used as the app's initialization entry point, and it is called as part of the ",(0,i.jsx)(n.code,{children:"application"})," launch block. Doodle apps can be created in a platform agnostic way and placed into the ",(0,i.jsx)(n.code,{children:"commonMain"})," source set so they are usable on multiple targets. This is how we will define the Calculator app."]}),"\n",(0,i.jsx)(n.p,{children:"This app will be fairly simple: just create an instance of our calculator and add it to the display."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/CalculatorApp.kt#L11",children:(0,i.jsx)(n.strong,{children:"CalculatorApp.kt"})})}),"\n",(0,i.jsx)(r.v,{children:"\npackage io.nacular.doodle.examples\n\n// ...\n\nclass CalculatorApp(display: Display): Application {\n  init {\n      // creat and display a single Calculator\n      display += Calculator()\n  }\n\n  override fun shutdown() { /* no-op */ }\n}\n"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,i.jsx)(n.h2,{id:"app-launcher",children:"App Launcher"}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps can be ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. Use the ",(0,i.jsx)(n.code,{children:"application"})," function in a platform source-set (i.e. ",(0,i.jsx)(n.code,{children:"jsMain"}),", ",(0,i.jsx)(n.code,{children:"jvmMain"}),", etc.) to launch top-level apps. It takes a list of modules to load and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,i.jsx)(n.code,{children:"instance"}),", ",(0,i.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"main.kt"})}),"\n",(0,i.jsx)(r.v,{children:c}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we have included the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/text#fonts",children:(0,i.jsx)(n.code,{children:"FontModule"})})," and ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/user_input/pointer",children:(0,i.jsx)(n.code,{children:"PointerModule"})}),". These are needed to enable font loading and pointer interactions. Our app will not directly know we loaded the ",(0,i.jsx)(n.code,{children:"PointerModule"}),", but pointer related events will only work because we have."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Check out ",(0,i.jsx)(n.a,{href:"https://github.com/kosi-libs/Kodein",children:"Kodein"})," to learn more about how it handles dependency injection."]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"application"})," function also takes an optional HTML element (for Web targets) within which the app will be hosted. The app will be hosted in ",(0,i.jsx)(n.code,{children:"document.body"})," if no element is specified."]}),"\n",(0,i.jsx)(n.p,{children:"App launching is the only part of our code that is platform-specific. This makes sense, since it is where we define concrete dependencies to pass into our app that can vary by platform. It is also where we control how our app runs, which is platform specific."}),"\n",(0,i.jsx)(n.h2,{id:"calculator-view",children:"Calculator View"}),"\n",(0,i.jsxs)(n.p,{children:["We will implement our calculator as a single ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/views",children:(0,i.jsx)(n.code,{children:"View"})})," that manages its state directly. This makes sense for simple use-cases, but might not be the right choice for larger apps."]}),"\n",(0,i.jsxs)(n.p,{children:["This View will be broken into a hierarchy of views, with two top-level items: a custom ",(0,i.jsx)(n.code,{children:"Output"})," and a ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#gridpanel",children:(0,i.jsx)(n.code,{children:"GridPanel"})}),"."]}),"\n",(0,i.jsx)(l.I,{function:"calculatorImages",height:"500"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L48",children:(0,i.jsx)(n.strong,{children:"Output"})})," is a really simple ",(0,i.jsx)(n.code,{children:"View"}),' that tracks a number and its text representation, which it renders to the screen. It also exposes the number as the current "answer" on the calculator. Its most complex role is displaying the text with proper alignment and scaling to avoid any clipping.']}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Notice how the output text starts off center aligned with the operator buttons; and how it shrinks as the number grows beyond the screen size."})}),"\n",(0,i.jsxs)(n.p,{children:["Take a look at the ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L48",children:(0,i.jsx)(n.strong,{children:"Output"})})," class, and you will see it has a ",(0,i.jsx)(n.code,{children:"text"})," property that it tracks the width of. It also uses ",(0,i.jsx)(n.code,{children:"textTransform"})," to perform the text scaling."]}),"\n",(0,i.jsx)(r.v,{children:'\nprivate inner class Output: View() {\n  //...\n\n  // Transform used to scale text down as it grows beyond window width\n  private var textTransform = Identity\n\n  //...\n\n  /** Text representation of number */\n  var text = "0"\n      set(new) {\n          field = new\n          val textWidth   = textMetrics.width(field, font)\n          val windowWidth = width - inset * 2\n\n          // use transform when text grows beyond window width\n          textTransform = when {\n              textWidth > windowWidth -> (windowWidth/textWidth).let { Identity.scale(x = it, y = it, around = Point(width / 2, height)) }\n              else                    -> Identity\n          }\n\n          rerender()\n      }\n\n  //...\n\n  override fun render(canvas: Canvas) {\n      val textPosition = textMetrics.size(text, font).let {\n          val x = when {\n              textTransform.isIdentity -> width - it.width - inset\n              else                     -> (width - it.width) / 2\n          }\n\n          Point(x, height - it.height)\n      }\n\n      // scaling, if present, is applied to the canvas before text rendered\n      canvas.transform(textTransform) {\n          text(text, at = textPosition, font = font, color = foregroundColor ?: White)\n      }\n  }\n}\n'}),"\n",(0,i.jsx)(n.h2,{id:"more-dependencies",children:"More Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Output"})," class, and others in ",(0,i.jsx)(n.code,{children:"Calculator"})," need things like fonts, and the ability to measure text. Doodle provides these capabilities via interfaces like ",(0,i.jsx)(n.code,{children:"FontLoader"})," and ",(0,i.jsx)(n.code,{children:"TextMetrics"}),". These are provided to ",(0,i.jsx)(n.code,{children:"Calculator"})," via constructor injection. That results in a constructor as follows:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L35",children:(0,i.jsx)(n.strong,{children:"Calculator.kt"})})}),"\n",(0,i.jsx)(r.v,{children:"\nclass Calculator(\n  private val fonts          : FontLoader,\n              appScope       : CoroutineScope,\n  private val textMetrics    : TextMetrics,\n  private val numberFormatter: NumberFormatter\n): View() {\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["This means ",(0,i.jsx)(n.code,{children:"CalculatorApp"})," needs to be updated as well. We continue by injecting these dependencies there."]}),"\n",(0,i.jsx)(r.v,{children:h}),"\n",(0,i.jsxs)(n.p,{children:["Now ",(0,i.jsx)(n.code,{children:"main"})," needs to provide these, along with ",(0,i.jsx)(n.code,{children:"Display"}),", when constructing the app."]}),"\n",(0,i.jsx)(r.v,{children:c}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"TextMetrics"}),", ",(0,i.jsx)(n.code,{children:"FontLoader"})," and is not included in Doodle's default modules, so we have to load it explicitly using the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/text#fonts",children:(0,i.jsx)(n.code,{children:"FontModule"})}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"the-buttons",children:"The Buttons"}),"\n",(0,i.jsxs)(n.p,{children:["We can manage the set of buttons within the calculator with a ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#gridpanel",children:(0,i.jsx)(n.code,{children:"GridPanel"})}),", which provides the kind of layout we need. This results in the following initialization for ",(0,i.jsx)(n.code,{children:"Calculator"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L35",children:(0,i.jsx)(n.strong,{children:"Calculator.kt"})})}),"\n",(0,i.jsx)(r.v,{children:u}),"\n",(0,i.jsx)(n.p,{children:"The final initialization steps are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Load fonts"}),"\n",(0,i.jsxs)(n.li,{children:["Setup buttons in ",(0,i.jsx)(n.code,{children:"GridPanel"})]}),"\n",(0,i.jsxs)(n.li,{children:["Add ",(0,i.jsx)(n.code,{children:"Output"})," and ",(0,i.jsx)(n.code,{children:"grid"})," as children"]}),"\n",(0,i.jsxs)(n.li,{children:["Configure the ",(0,i.jsx)(n.code,{children:"layout"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This example uses non-standard/recommended property names for buttons to improve readability slightly. This also makes tests a little simpler to understand."}),"\n",(0,i.jsx)(n.h2,{id:"button-styling",children:"Button Styling"}),"\n",(0,i.jsxs)(n.p,{children:["The calculator buttons come in a few different color schemes. But they all share the same ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/behaviors",children:(0,i.jsx)(n.code,{children:"Behavior"})}),", defined by ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/CalcButtonBehavior.kt#L16",children:(0,i.jsx)(n.code,{children:"CalcButtonBehavior"})}),". Buttons--like many Views--let you define their look-and-feel using a ",(0,i.jsx)(n.code,{children:"Behavior"}),". Ours is fairly simple; it draws the rounded rectangle for the button background and centers the text above it. These are both managed with the right color based on the button's state. It gets state tracking and text positioning for free via its base class: ",(0,i.jsx)(n.code,{children:"CommonButtonBehavior"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"custom-hit-detection",children:"Custom Hit Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/CalcButtonBehavior.kt#L16",children:(0,i.jsx)(n.code,{children:"CalcButtonBehavior"})})," provides a rounded style for our buttons. But the default hit-detection for Views is tied to their rectangular bounds. We can fix this by writing custom pointer hit-detection in our behavior."]}),"\n",(0,i.jsx)(r.v,{children:"\nclass CalcButtonBehavior(textMetrics: TextMetrics): CommonTextButtonBehavior<Button>(textMetrics) {\n  //...\n\n  override fun contains(view: Button, point: Point): Boolean {\n      val radius      = view.height / 2\n      val leftCircle  = Circle(center = Point(view.x + radius,            view.center.y), radius = radius)\n      val rightCircle = Circle(center = Point(view.bounds.right - radius, view.center.y), radius = radius)\n\n      return when {\n          point.x < radius              -> point in leftCircle\n          point.x > view.width - radius -> point in rightCircle\n          else                          -> point in view.bounds\n      }\n  }\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contains(Button, Point)"})," method is called by ",(0,i.jsx)(n.code,{children:"Button"}),' to check whether the pointer is within its bounds. This logic ensures the pointer will only "hit" our button when it goes within the rounded rectangle.']}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contains"})," check provides a ",(0,i.jsx)(n.code,{children:"Point"})," in the View's ",(0,i.jsx)(n.strong,{children:"parent's"})," coordinates."]})}),"\n",(0,i.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,i.jsxs)(n.p,{children:["Doodle is designed to avoid platform specific dependencies except in the small amount of launch code. The ",(0,i.jsx)(n.code,{children:"CalculatorApp"})," and ",(0,i.jsx)(n.code,{children:"Calculator"})," are written in ",(0,i.jsx)(n.code,{children:"commonMain"}),", which means we can test them by writing tests in ",(0,i.jsx)(n.code,{children:"commonTest"})," and running them on each platform."]}),"\n",(0,i.jsx)(n.p,{children:"In our case, we will use the Mockk library for testing, which means we will actually only write tests for the JVM where that library works. Test speed is a big advantage of this setup, since there are no external dependencies."}),"\n",(0,i.jsxs)(n.p,{children:["The tests in ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/jvmTest/kotlin/io/nacular/doodle/examples/CalculatorTests.kt#L18",children:(0,i.jsx)(n.code,{children:"CalculatorTests"})})," are a bit contrived, but they illustrate how you might validate various parts of your app."]})]})}function v(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}}}]);