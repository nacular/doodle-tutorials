"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[444],{6331:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>g,frontMatter:()=>d,metadata:()=>c,toc:()=>h});var a=n(7462),i=(n(7294),n(3905)),o=(n(8209),n(5488)),r=n(5162),l=n(3138),s=n(6823);const d={title:"Animating Tab Strip",hide_title:!0},p="[TabStrip](https://github.com/nacular/doodle-tutorials/tree/master/TabStrip) Tutorial",c={unversionedId:"tabstrip",id:"tabstrip",title:"Animating Tab Strip",description:"We will build a simple app that hosts animating tab selection component in this tutorial. It is inspired by Cuberto's Animated Tabbar and this JS impl. This app will be multi-platform, which means it will run in the browser and as a desktop application.",source:"@site/docs/tabstrip.mdx",sourceDirName:".",slug:"/tabstrip",permalink:"/doodle-tutorials/docs/tabstrip",draft:!1,tags:[],version:"current",frontMatter:{title:"Animating Tab Strip",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/doodle-tutorials/docs/introduction"},next:{title:"Contacts",permalink:"/doodle-tutorials/docs/contacts"}},m={},h=[{value:"Project Setup",id:"project-setup",level:2},{value:"Defining Our Application",id:"defining-our-application",level:2},{value:"Launching on Web and Desktop",id:"launching-on-web-and-desktop",level:2},{value:"The TabStrip View",id:"the-tabstrip-view",level:2},{value:"Render Logic",id:"render-logic",level:3},{value:"Triggering The Animation",id:"triggering-the-animation",level:3},{value:"Animation Timeline",id:"animation-timeline",level:3},{value:"Animation Logic",id:"animation-logic",level:3},{value:"Rendering On Animation",id:"rendering-on-animation",level:3},{value:"Potential Improvements",id:"potential-improvements",level:2}],u={toc:h};function g(e){let{components:t,...d}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,d,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tabstrip-tutorial"},(0,i.kt)("a",{parentName:"h1",href:"https://github.com/nacular/doodle-tutorials/tree/master/TabStrip"},"TabStrip")," Tutorial"),(0,i.kt)("p",null,"We will build a simple app that hosts animating tab selection component in this tutorial. It is inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://dribbble.com/shots/14723171-Animated-Tabbar"},"Cuberto's Animated Tabbar")," and this ",(0,i.kt)("a",{parentName:"p",href:"https://codepen.io/aaroniker/pen/rNMmZvq?editors=0110"},"JS impl"),". This app will be multi-platform, which means it will run in the browser and as a desktop application."),(0,i.kt)("p",null,"The main focus will be utilizing ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/animations"},"Doodle's powerful animation APIs")," to create smooth transitions with precise timings."),(0,i.kt)(l.B,{functionName:"tabStrip",height:"300",mdxType:"DoodleCodeBlock"}),(0,i.kt)("p",null,"You can also see the full-screen app ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle-tutorials/tabstrip"},"here"),"."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"project-setup"},"Project Setup"),(0,i.kt)("p",null,"This app (like the others in this tutorial) is created as a multi-platform library, with a multiplatform launcher that depends on it.\nThis is not necessary to use Doodle. You could create a single multiplatform build with the common parts of your app\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"commonMain")," etc.. This setup is used here because the app are also launched by an app within ",(0,i.kt)("inlineCode",{parentName:"p"},"DocApps")," when embedding it\nlike below. Therefore, we need a pure library for the app. This is why there is an app and a runner."),(0,i.kt)("mermaid",{value:" classDiagram\n      TabStrip      <|-- TabStripRunner\n      TabStrip      <|-- DocApps\n      TabStripRunner: commonMain.resources\n      TabStripRunner: jvmMain.main\n      TabStripRunner: jsMain.main\n      DocApps       : main\n      TabStrip      : commonMain\n      TabStrip      : jvmMain\n      TabStrip      : jsMain"}),(0,i.kt)(o.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"TabStrip",mdxType:"TabItem"},(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/TabStrip/build.gradle.kts"},(0,i.kt)("strong",{parentName:"a"},"build.gradle.kts"))),(0,i.kt)(s.Z,{language:"kotlin",mdxType:"CodeBlock"},'plugins {\n    kotlin("multiplatform")\n}\n\nkotlin {\n    jsTargets (BOTH)\n    jvmTargets()\n\n    val doodleVersion: String by project\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation(kotlin("stdlib-common"))\n                api("io.nacular.doodle:core:$doodleVersion"     )\n                api("io.nacular.doodle:controls:$doodleVersion" )\n                api("io.nacular.doodle:animation:$doodleVersion")\n            }\n        }\n    }\n}')),(0,i.kt)(r.Z,{value:"TabStripRunner",mdxType:"TabItem"},(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/TabStripRunner/build.gradle.kts"},(0,i.kt)("strong",{parentName:"a"},"build.gradle.kts"))),(0,i.kt)(s.Z,{language:"kotlin",mdxType:"CodeBlock"},'plugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    js {\n        browser()\n        binaries.executable()\n    }\n\n    jvm {\n        withJava()\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = "11"\n            }\n        }\n    }\n\n    val doodleVersion: String by project\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation(project(":TabStrip"))\n            }\n        }\n\n        val jsMain by getting {\n            dependencies {\n                implementation ("io.nacular.doodle:browser:$doodleVersion")\n            }\n        }\n\n        val jvmMain by getting {\n            dependencies {\n                val osName = System.getProperty("os.name")\n                val targetOs = when {\n                    osName == "Mac OS X"       -> "macos"\n                    osName.startsWith("Win"  ) -> "windows"\n                    osName.startsWith("Linux") -> "linux"\n                    else                       -> error("Unsupported OS: $osName")\n                }\n\n                val targetArch = when (val osArch = System.getProperty("os.arch")) {\n                    "x86_64", "amd64" -> "x64"\n                    "aarch64"         -> "arm64"\n                    else              -> error("Unsupported arch: $osArch")\n                }\n\n                val target = "${targetOs}-${targetArch}"\n\n                implementation ("io.nacular.doodle:desktop-jvm-$target:$doodleVersion")\n            }\n        }\n    }\n}\n\napplication {\n    mainClass.set("io.nacular.doodle.examples.MainKt")\n}\n\ninstallFullScreenDemo("Development")\ninstallFullScreenDemo("Production" )'))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"defining-our-application"},"Defining Our Application"),(0,i.kt)("p",null,"All Doodle apps must implement the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle/blob/master/Core/src/commonMain/kotlin/io/nacular/doodle/application/Application.kt#L4"},(0,i.kt)("inlineCode",{parentName:"a"},"Application")),"\ninterface. The framework will then initialize our app via the constructor. Our app will be fairly simple: just create\nan instance of our calculator and add it to the display."),(0,i.kt)("p",null,"Doodle apps can be defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"commonMain"),", since they do not require any platform-specific dependencies. Therefore, we will do\nthe same and place ours in ",(0,i.kt)("inlineCode",{parentName:"p"},"commonMain/kotlin/io/nacular/doodle/examples"),"."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/nacular/doodle-tutorials/blob/master/TabStrip/src/commonMain/kotlin/io/nacular/doodle/examples/TabStripApp.kt#L11"},(0,i.kt)("strong",{parentName:"a"},"TabStripApp.kt"))),(0,i.kt)(s.Z,{language:"kotlin",mdxType:"CodeBlock"},"package io.nacular.doodle.examples\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.geometry.PathMetrics\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.center\nimport io.nacular.doodle.layout.constraints.constrain\n\n/**\n * Simple app that places a [TabStrip] at the center of the display.\n */\nclass TabStripApp(display: Display, animator: Animator, pathMetrics: PathMetrics): Application {\n    init {\n        // creat and display a single TabStrip\n        with(display) {\n            this += TabStrip(animator, pathMetrics).apply {\n                size = Size(375, 100)\n            }\n\n            layout = constrain(first(), center)\n        }\n    }\n\n    override fun shutdown() { /* no-op */ }\n}"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Notice that ",(0,i.kt)("inlineCode",{parentName:"p"},"shutdown")," is a no-op, since we don't have any cleanup to do when the app closes.")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"launching-on-web-and-desktop"},"Launching on Web and Desktop"),(0,i.kt)("p",null,"Doodle apps can be ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/applications"},"launched")," in a few different ways on Web and Desktop. We defined our app logic\nin a multi-platform ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip")," library (no ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," functions), so it can be used on both platforms. Notice that we are only using a library here because we also want to run the TabStrip in our documentation app. That app will run it as an embedded Web app, which becomes easier if it is a library. Otherwise, we could have defined our platform ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," functions directly in the ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip")," module. Instead, we created a separate ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStripRunner")," module that contains our ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," functions."),(0,i.kt)(s.Z,{language:"kotlin",title:"main.kt",mdxType:"CodeBlock"},'package io.nacular.doodle.examples\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.AnimatorImpl\nimport io.nacular.doodle.application.Modules.Companion.PointerModule\nimport io.nacular.doodle.application.application\nimport io.nacular.doodle.geometry.PathMetrics\nimport io.nacular.doodle.geometry.impl.PathMetricsImpl\nimport org.kodein.di.DI.Module\nimport org.kodein.di.bindSingleton\nimport org.kodein.di.instance\n\n/**\n * Creates a [TabStripApp]\n */\nfun main() {\n    application(modules = listOf(PointerModule, Module(name = "AppModule") {\n        bindSingleton<Animator>    { AnimatorImpl   (instance(), instance()) }\n        bindSingleton<PathMetrics> { PathMetricsImpl(instance()            ) }\n    })) {\n        // load app\n        TabStripApp(instance(), instance(), instance())\n    }\n}'),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"the-tabstrip-view"},"The TabStrip View"),(0,i.kt)("p",null,"This tutorial will implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip")," as a single ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/views"},(0,i.kt)("inlineCode",{parentName:"a"},"View"))," that manages its state directly. This lets us focus on the animation logic."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"A production version of this control would be more flexible if it let you pass in the items in the tab and configure what each does when clicked.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip")," is composed of a rounded rectangle background (with a drop-shadow), a row of items rendered using paths an indicator that looks like a wave, and a droplet that appears during a new tab selection. All of these elements are rendered directly onto the ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip"),"'s canvas, so there are no child ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),"s involved for this approach."),(0,i.kt)("h3",{id:"render-logic"},"Render Logic"),(0,i.kt)("p",null,"All parts of the view are rendered in ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip.render"),", which is how all Views draw themselves."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"override fun render(canvas: Canvas) {\n    val foreGround = (foregroundColor ?: Black).paint\n    val backGround = (backgroundColor ?: White).paint\n\n    // draw shadow\n    canvas.outerShadow(color = Black opacity 0.1f, blurRadius = 20.0) {\n        // draw background rounded rect\n        canvas.rect(bounds.atOrigin, radius = cornerRadius, fill = backGround)\n    }\n\n    // draw items\n    items.forEach { item ->\n        val itemScale = 1 - itemScaleChange * item.moveProgress\n\n        // position and scale the item\n        canvas.transform(Identity.\n            translate(Point(item.x, item.y + itemDipOffset * item.moveProgress)).\n            scale(around = Point(item.width / 2, item.height / 2), itemScale, itemScale)) {\n\n            when (item.selectionProgress) {\n                1f   -> path(item.selected, fill = foreGround) // fully selected\n                else -> {\n                    path(item.deselected, fill = foreGround)\n\n                    if (item.selectionProgress > 0f) {\n                        // overlay transition if partially selected\n                        val dropletCircle = Circle(\n                            center = Point(item.width / 2, item.height - dropLetRadius),\n                            radius = dropLetRadius + (max(item.width, item.height) - dropLetRadius) * item.selectionProgress\n                        )\n\n                        // overlay background fill so it seeps through holes in item\n                        circle(dropletCircle, fill = backGround)\n\n                        // draw selected item clip to droplet\n                        clip(dropletCircle) {\n                            path(item.selected, fill = foreGround)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    canvas.translate(indicatorCenter) {\n        // draw indicator\n        path(indicatorPath, fill = foreGround)\n\n        if (dropletYAboveIndicator != 0.0) {\n            // draw droplet so that it's top is at the indicator top when dropletYAboveIndicator == 0\n            circle(Circle(\n                radius = dropLetRadius,\n                center = Point(0, -indicatorHeight + dropLetRadius - dropletYAboveIndicator)\n            ), fill = foreGround)\n        }\n    }\n}\n")),(0,i.kt)("p",null,"Notice that the icons and indicator are all drawn after the canvas has been transformed. That is because paths are fixed in space (in our case they are all anchored at ",(0,i.kt)("inlineCode",{parentName:"p"},"0,0"),") and moving them around on a Canvas requires a transform."),(0,i.kt)("p",null,"You can also see that each icon can be in 1 of 3 states: ",(0,i.kt)("em",{parentName:"p"},"deselected"),", ",(0,i.kt)("em",{parentName:"p"},"partially selected"),", ",(0,i.kt)("em",{parentName:"p"},"fully selected"),". In the first and last case, only the respective path is drawn. But in the transitional state, both paths are drawn, with the selected path being clipped to the droplet circle. We also need to change the background color that leaks through the holes of the path. So a filler circle is drawn before the selected path with the current background fill."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Many of the parameters used in ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," are ones we will animate (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"icon.moveProgress"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"icon.selectionProgress"),", `",(0,i.kt)("inlineCode",{parentName:"p"},"indicatorCenter"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dropletYAboveIndicator"),", etc.). Therefore, animation can simply trigger renders to ensure the ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip")," always reflects the changes on every tick.")),(0,i.kt)("h3",{id:"triggering-the-animation"},"Triggering The Animation"),(0,i.kt)("p",null,"This component has a complex set of animation that will trigger in a specific sequence to achieve the final look. We will use an injected ",(0,i.kt)("inlineCode",{parentName:"p"},"Animator")," names ",(0,i.kt)("inlineCode",{parentName:"p"},"animate")," to perform all animations. And we will tie animations to click events that select a new item."),(0,i.kt)("p",null,"The first thing we'll do is track the ",(0,i.kt)("inlineCode",{parentName:"p"},"selectedItem")," as an ",(0,i.kt)("inlineCode",{parentName:"p"},"observable")," property so we can trigger animations when it changes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"private var selectedItem by observable(items.first()) { _,selected -> ... }\n")),(0,i.kt)("p",null,"This item will be initialized to the first item in our list. That list will simply be hard-coded for this tutorial. It tracks data for each item in a simple data object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"private inner class ItemState(val selected: Path, val deselected: Path, var selectionProgress: Float = 0f) {\n    val x          get() = position.x\n    val y          get() = position.y\n    val width      get() = size.width\n    val height     get() = size.height\n    val centerX    get() = x + width / 2\n    val size             = pathMetrics.size(selected)\n    val atDefaults get() = selectionProgress == 0f && moveProgress == 0f\n\n    lateinit var position     : Point\n             var moveProgress = 0f\n}\n")),(0,i.kt)("p",null,"The user is able to change ",(0,i.kt)("inlineCode",{parentName:"p"},"selectedItem")," by clicking on it with the Pointer. We track this by listening to click events on the view directly and deciding which item is selected. We also listen for pointer move events to handle the dynamic cursor, which shows a Pointer when hovering over a non-selected item."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"init {\n    // ...\n\n    // Listen for item clicks\n    pointerChanged += clicked { event ->\n        getItem(at = event.location)?.let {\n            selectedItem = it\n            cursor       = Default\n        }\n    }\n\n    // Update cursor as pointer moves\n    pointerMotionChanged += moved { event ->\n        cursor = when (getItem(event.location)) {\n            selectedItem, null -> Default\n            else               -> Pointer\n        }\n    }\n}\n")),(0,i.kt)("p",null,"The result is that clicking on an item other than ",(0,i.kt)("inlineCode",{parentName:"p"},"selectedItem")," will trigger our observable callback, which is where we do our animation handling."),(0,i.kt)("h3",{id:"animation-timeline"},"Animation Timeline"),(0,i.kt)("p",null,"This is what the full animation timeline looks like. The diagram shows the sequence of events and their timings (to scale)."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(4429).Z,width:"1920",height:"1080"})),(0,i.kt)("p",null,"There are a few important things to note about our approach. First is that we are using an animation block and tracking several top-level animations that will run concurrently via ",(0,i.kt)("inlineCode",{parentName:"p"},"animations"),". This allows us to auto-cancel them whenever a new animation starts. We accomplish this by defining ",(0,i.kt)("inlineCode",{parentName:"p"},"animations")," as an ",(0,i.kt)("inlineCode",{parentName:"p"},"autoCanceling")," property"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"private var animation: Animation<*>? by autoCanceling()\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"autoCanceling")," delegate to get free animation cleanup whenever a new value is assigned to an old one.")),(0,i.kt)("p",null,"Secondly, our approach initiates a lot of follow-on animations at the completion of previous animations (denoted with the dotted lines). Unfortunately, these will not be tracked by our top-level animation block, since blocks only track animations created when the block is executed (see below). So we will need to track all of these to cancel them if tab changes happen during an ongoing animation. These are all lumped into a ",(0,i.kt)("inlineCode",{parentName:"p"},"secondaryAnimations")," set."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Doodle's animation block captures any animations created while the block is being executed and groups them all under a single animation returned from the block. In the following example, all the animations will be tied to ",(0,i.kt)("inlineCode",{parentName:"p"},"animations"),", so canceling it cancels everything."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="All animations rolled into the result"',title:'"All',animations:!0,rolled:!0,into:!0,the:!0,'result"':!0},"val animations = animate {\n    0f to 1f using tweenFloat(...).invoke {}\n    a  to b  using tweenColor(...).invoke {}\n\n    subAnimation = animate {\n        ...\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Doing the following ",(0,i.kt)("strong",{parentName:"p"},"will not")," track the animation created in the ",(0,i.kt)("inlineCode",{parentName:"p"},"completed")," callback."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Some animations not tracked"',title:'"Some',animations:!0,not:!0,'tracked"':!0},"val animations = animate {\n    (0f to 1f using tweenFloat(...).invoke {}).apply {\n        completed += {\n            // this one not, since it is created after the animate block is finished\n            a  to b  using tweenColor(...).invoke {}\n        }\n    }\n}\n\n"))),(0,i.kt)("p",null,"We use the second pattern to chain animations together, which means our ",(0,i.kt)("inlineCode",{parentName:"p"},"animations")," property is only tracking a subset. Of course, we could have made this work by tracking start/end times and using delays for all subsequent animations. But that is a bit more tedious."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"A future version of Doodle could provide ways to offset animations in a block relative to those already defined, which would better serve this use case.")),(0,i.kt)("h3",{id:"animation-logic"},"Animation Logic"),(0,i.kt)("p",null,"The following code has all of the logic to setup the timeline, track secondary animations and cancel anything that is ongoing when it fires."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"private var selectedItem by observable(items.first()) { _,selected ->\n\n    // cancel any ongoing secondary animations and hide droplet\n    dropletYAboveIndicator = 0.0\n    secondaryAnimations.forEach { it.cancel() }\n    secondaryAnimations.clear()\n\n    // Animation blocks roll all top-level animations (those created while in the block) into a common\n    // parent animation. Canceling that animation cancels all the children.\n    // However, our code creates additional animations that are created when top-level ones are completed.\n    // These animations are NOT tracked as part of the returned animation group. So they need to be tracked\n    // separately, so we can cancel them if anything changes mid-flight.\n    // We do that using the secondaryAnimations set.\n    animation = animate {\n        // Animate all deselected items back to normal\n        items.filter { it != selected && !it.atDefaults }.forEach { deselected ->\n            deselected.moveProgress      to 0f using (tweenFloat(linear, itemMoveUpDuration)) { deselected.moveProgress      = it }\n            deselected.selectionProgress to 0f using (tweenFloat(linear, itemFillDuration  )) { deselected.selectionProgress = it }\n        }\n\n        // Indicator moves to selected item\n        (indicatorCenter.x to selected.centerX using (tweenDouble(easeInOutCubic, slideDuration)) { indicatorCenter = Point(it, height) }).onCompleted {\n            // Selected item moves down\n            (selected.moveProgress to 1f using (tweenFloat(linear, itemMoveDownDuration)) { selected.moveProgress = it }).also { secondaryAnimations += it }\n        }\n\n        // Indicator primes as it travels to selected item\n        (indicatorHeight to minIndicatorHeight using (tweenDouble(linear, primeDuration)) { indicatorHeight = it }).onCompleted {\n            // NOTE: All these are secondary animations that won't be attached to the outer animation, since it would have been\n            // completed at this point. So they need to be tracked using our secondaryAnimation set.\n\n            // Indicator fires at selected item\n            (indicatorHeight to maxIndicatorHeight using (tweenDouble(linear, fireDuration)) { indicatorHeight = it }).onCompleted {\n                // Indicator height returns to normal\n                (indicatorHeight to defaultIndicatorHeight using (tweenDouble(linear, recoilDuration)) { indicatorHeight = it }).also { secondaryAnimations += it }\n\n                // Droplet moves up to item\n                (dropletYAboveIndicator to dropletMaxY using (tweenDouble(linear, dropletTravelDuration)) { dropletYAboveIndicator = it }).onCompleted {\n                    // Hide droplet\n                    dropletYAboveIndicator = 0.0\n\n                    // Selected item moves up\n                    (selected.moveProgress to 0f using (tweenFloat(linear, itemMoveUpDuration)) { selected.moveProgress = it }).also { secondaryAnimations += it }\n\n                    // Item animates droplet within it\n                    (selected.selectionProgress to 1f using (tweenFloat(linear, itemFillDuration)) { selected.selectionProgress = it }).also { secondaryAnimations += it }\n                }.also { secondaryAnimations += it }\n            }.also { secondaryAnimations += it }\n        }.also { secondaryAnimations += it }\n    }\n}\n")),(0,i.kt)("h3",{id:"rendering-on-animation"},"Rendering On Animation"),(0,i.kt)("p",null,"Our animations change many internal variables as they update. These variables all affect how the control is rendered, and therefore need to trigger re-render so their states are constantly in sync with what the control shows at any moment. One option is to have these variables be ",(0,i.kt)("inlineCode",{parentName:"p"},"renderProperty"),"s. This would trigger a render call whenever any of them is changed. This approach is fine for cases where only a small number of properties will change at a time; then the number of render calls remains low. Doodle does queue calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"rerender"),", but its best to avoid making those calls to begin with if possible."),(0,i.kt)("p",null,"So we take a different approach. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Animator")," interface lets you listen to changes to active animations. These events are fired in bulk whenever any animations change, complete, or are canceled. This is a great way to take action at low cost. The code for this is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"init {\n    // ...\n\n    // Rerender on animation updates\n    animate.listeners += object: Listener {\n        override fun changed(animator: Animator, animations: Set<Animation<*>>) {\n            rerenderNow() // only called once per animation tick\n        }\n    }\n\n    // ...\n}\n")),(0,i.kt)("p",null,"With this, our component will render itself and listen to pointer events so it can trigger animations."),(0,i.kt)("h2",{id:"potential-improvements"},"Potential Improvements"),(0,i.kt)("p",null,"We focused on the animation logic in this tutorial, but there are other things the ",(0,i.kt)("inlineCode",{parentName:"p"},"TabStrip")," needs to manage given how we've chosen to implement it. These include managing how all the items it draws are positioned relative to its own size."),(0,i.kt)("p",null,"The approach we chose requires the component to recalculate the offsets of all paths it draws whenever its size changes. That's because everything drawn during render is absolutely positioned on the canvas."),(0,i.kt)("p",null,"A more production-ready approach might have the component only draw the indicator on its canvas, while having the items as child views. Then it could use a ",(0,i.kt)("a",{parentName:"p",href:"https://nacular.github.io/doodle/docs/layout/overview"},(0,i.kt)("inlineCode",{parentName:"a"},"Layout"))," to keep the item positions up to date. Of course, that ",(0,i.kt)("inlineCode",{parentName:"p"},"layout")," would need to participate in the animation and incorporate the animating values into its positioning logic. But this approach would scale better and allow the control to house a more dynamic set of items."))}g.isMDXComponent=!0},4429:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/animation-full-e92bb82663596590235bd54fe0e1993e.png"}}]);