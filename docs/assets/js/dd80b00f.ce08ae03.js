"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[619],{109:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>h,default:()=>v,frontMatter:()=>c,metadata:()=>p,toc:()=>u});var i=t(4848),a=t(8453);const o='plugins {\n    kotlin("multiplatform"          )\n    alias(libs.plugins.serialization)\n}\n\nkotlin {\n    // Defined in buildSrc/src/main/kotlin/Common.kt\n    jsTargets    (executable = true)\n    wasmJsTargets(executable = true)\n\n    sourceSets {\n        jsMain {\n            dependencies {\n                implementation(libs.bundles.ktor.client)\n                implementation(libs.coroutines.core    )\n                implementation(libs.serialization.json )\n\n                api(libs.doodle.browser )\n                api(libs.doodle.controls)\n                api(libs.doodle.themes  )\n            }\n        }\n    }\n}';var s=t(854);const l="package io.nacular.doodle.examples\n\nimport io.ktor.client.*\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.list.DynamicList\nimport io.nacular.doodle.controls.panels.ScrollPanel\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.theme.adhoc.DynamicTheme\nimport io.nacular.doodle.theme.basic.list.basicVerticalListBehavior\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\n\n/**\n * Streams an unbounded list of images from unsplash and displays them in a list.\n */\n//sampleStart\nclass PhotoStreamApp(display    : Display,\n                     themes     : ThemeManager,\n                     theme      : DynamicTheme,\n                     httpClient : HttpClient,\n                     imageLoader: ImageLoader): Application {\n    init {\n        // For scroll panel behavior\n        themes.selected = theme\n\n        val appScope    = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n        val imageHeight = 400.0\n\n        // List to hold images\n        val list = DynamicList(\n            model          = UnSplashDataModel(appScope, httpClient, imageLoader),\n            itemVisualizer = itemVisualizer { image, recycledView, _ -> when(recycledView) {\n                is CenterCroppedPhoto -> recycledView.also { recycledView.image = image }\n                else                  -> CenterCroppedPhoto(image)\n            } }\n        ).apply {\n            behavior      = basicVerticalListBehavior(itemHeight = imageHeight)\n            cellAlignment = fill\n        }\n\n        display += ScrollPanel(list).apply {\n            // Ensure list's width is equal to scroll-panel's\n            contentWidthConstraints = { it eq parent.width - verticalScrollBarWidth }\n        }\n\n        display.layout = constrain(display.children[0]) {\n            it.width   eq min(parent.width, imageHeight)\n            it.height  eq parent.height\n            it.centerX eq parent.centerX\n        }\n    }\n\n    override fun shutdown() {}\n}\n//sampleEnd",r='package io.nacular.doodle.examples\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.nacular.doodle.controls.DynamicListModel\nimport io.nacular.doodle.controls.ModelObserver\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.utils.ObservableList\nimport io.nacular.doodle.utils.SetPool\nimport io.nacular.doodle.utils.observable\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.launch\nimport kotlinx.serialization.Serializable\nimport kotlin.properties.Delegates\n\n/**\n * DynamicListModel of Images that fetches data from Unsplash. This model provides a stream\n * of images by fetching every time the end of its current list is reached. Fetched images\n * are cached in memory.\n */\n//sampleStart\nclass UnSplashDataModel(\n    private val scope      : CoroutineScope,\n    private val client     : HttpClient,\n    private val imageLoader: ImageLoader,\n    private val accessToken: String = "YOUR_ACCESS_TOKEN"\n): DynamicListModel<Image> {\n    @Serializable\n    data class Urls(val small: String)\n\n    @Serializable\n    data class UnsplashPhoto(val id: String, val urls: Urls)\n\n    // Tracks current HTTP request\n    private var httpRequestJob: Job? by Delegates.observable(null) { _, old, _ ->\n        old?.cancel()\n    }\n\n    // Used to avoid fetching in the middle of an ongoing fetch\n    private var fetchActive = false\n\n    // Page being fetched from unsplash\n    private var currentPage: Int by observable(-1) { _, _ ->\n        fetchActive = true\n        httpRequestJob = scope.launch {\n            val results = client.get(unsplashLocation).body<List<UnsplashPhoto>>()\n\n            loadedImages.addAll(results.mapNotNull { imageLoader.load(it.urls.small) })\n\n            fetchActive = false\n\n            if (nextPageNeeded) {\n                nextPageNeeded = false\n                currentPage += 1\n            }\n        }\n    }\n\n    private val pageSize               = 5\n    private var nextPageNeeded         = false\n    private val unsplashLocation get() = "https://api.unsplash.com/photos/?client_id=$accessToken&page=$currentPage&per_page=$pageSize"\n\n    override val size get() = loadedImages.size\n\n    override val changed = SetPool<ModelObserver<Image>>()\n\n    // Internal list used to cache images loaded from unsplash\n    private val loadedImages = ObservableList<Image>().also {\n        it.changed += { _, differences ->\n            // notify model observers whenever the underlying list changes (due to image loads)\n            changed.forEach {\n                it(this, differences)\n            }\n        }\n    }\n\n    init {\n        currentPage = 0\n    }\n\n    override fun get(index: Int): Result<Image> = Result.runCatching {\n        loadedImages[index].also {\n            // Load the next page if the last image is fetched from the model\n            if (index == size - 1) {\n                when {\n                    fetchActive -> nextPageNeeded = true\n                    else        -> currentPage += 1\n                }\n            }\n        }\n    }\n\n    override fun contains(value: Image) = value in loadedImages\n    override fun iterator(                       ) = loadedImages.iterator()\n    override fun section (range: ClosedRange<Int>) = loadedImages.subList(range.start, range.endInclusive + 1)\n}\n//sampleEnd',d="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.image.height\nimport io.nacular.doodle.image.width\nimport kotlin.math.min\n\n/**\n * Renders an image with a center crop.\n */\n//sampleStart\nclass CenterCroppedPhoto(image: Image): View() {\n    private lateinit var centerCrop: Rectangle\n\n    var image: Image = image\n        set(new) {\n            field        = new\n            val cropSize = min(image.width, image.height)\n            centerCrop   = Rectangle((image.width - cropSize) / 2, (image.height - cropSize) / 2, cropSize, cropSize)\n\n            rerender()\n        }\n\n    init {\n        this.image = image // ensure setter called, so centerCrop initialized\n    }\n\n    override fun render(canvas: Canvas) {\n        canvas.image(image, source = centerCrop, destination = bounds.atOrigin)\n    }\n}\n//sampleEnd",c={title:"Photo Stream",hide_title:!0},h="Photo Stream Tutorial",p={id:"photostream",title:"Photo Stream",description:"We will build a simple Doodle app that displays an infinite stream of photos that are lazily loaded from unsplash.com.",source:"@site/docs/photostream.mdx",sourceDirName:".",slug:"/photostream",permalink:"/doodle-tutorials/docs/photostream",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Photo Stream",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Photos",permalink:"/doodle-tutorials/docs/photos"}},m={},u=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"Binding To Unsplash Data",id:"binding-to-unsplash-data",level:2},{value:"Presenting The Images",id:"presenting-the-images",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"photo-stream-tutorial",children:[(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/tree/master/PhotoStream",children:"Photo Stream"})," Tutorial"]}),"\n",(0,i.jsxs)(n.p,{children:["We will build a simple Doodle app that displays an infinite stream of photos that are lazily loaded from ",(0,i.jsx)(n.a,{href:"https://unsplash.com",children:"unsplash.com"}),".\nThe photos will be shown in a list that continuously grows as the user scrolls to the bottom."]}),"\n",(0,i.jsx)("div",{style:{textAlign:"center",margin:"3em 0"},children:(0,i.jsxs)("video",{autoPlay:!0,loop:!0,muted:!0,playsInline:!0,width:"400px",children:[(0,i.jsx)("source",{type:"video/mp4",src:"/doodle-tutorials/photo_stream_desktop.mov"}),(0,i.jsx)("p",{children:"Your browser does not support the video element."})]})}),"\n",(0,i.jsxs)(n.p,{children:["The first thing we need is an ",(0,i.jsx)(n.strong,{children:"Unsplash API"})," key. Take a look at their ",(0,i.jsx)(n.a,{href:"https://unsplash.com/documentation",children:"developer documentation"})," to obtain one.\nA key is required to make API requests and fetch image urls."]}),"\n",(0,i.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,i.jsx)(n.p,{children:"We will use a JS only-setup for this app. Our app will use Ktor for the HTTP client and Kotlin Serialization to unmarshal the resulting JSON.\nWe also need Kotlin's Coroutines library to load images asynchronously."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/PhotoStream/build.gradle.kts",children:(0,i.jsx)(n.strong,{children:"build.gradle.kts"})})}),"\n",(0,i.jsx)(s.v,{children:o}),"\n",(0,i.jsx)(n.h2,{id:"the-application",children:"The Application"}),"\n",(0,i.jsxs)(n.p,{children:["Our application will be fairly simple. It will create a ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#list",children:(0,i.jsx)(n.code,{children:"DynamicList"})})," with a data model bound to Unsplash's APIs. This list will be within a ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/core/io.nacular.doodle.controls.panels/-scroll-panel",children:(0,i.jsx)(n.code,{children:"ScrollPanel"})})," that fits the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/display/overview",children:(0,i.jsx)(n.code,{children:"Display"})})," height."]}),"\n",(0,i.jsx)(s.v,{children:l}),"\n",(0,i.jsx)(n.p,{children:"DynamicList monitors its model for changes and updates whenever items are added, removed, or moved. This means we can simply change the underlying model to get a list that grows."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"DynamicList"}),", like ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls.list/-list",children:(0,i.jsx)(n.code,{children:"List"})})," and ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls.list/-mutable-list",children:(0,i.jsx)(n.code,{children:"MutableList"})})," recycle their contents to avoid rendering items that are not displayed. The ",(0,i.jsx)(n.code,{children:"scrollCache"})," constructor parameter controls the amount of items in the buffer. Passing nothing means we get a default of 10 items cached beyond what is visible."]})}),"\n",(0,i.jsx)(n.h2,{id:"binding-to-unsplash-data",children:"Binding To Unsplash Data"}),"\n",(0,i.jsxs)(n.p,{children:["DynamicList requires a ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls/-dynamic-list-model",children:(0,i.jsx)(n.code,{children:"DynamicListModel"})})," to hold its data, so we need to create one that binds to Unsplash."]}),"\n",(0,i.jsx)(s.v,{children:r}),"\n",(0,i.jsxs)(n.p,{children:["Our model will cache a local ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/core/io.nacular.doodle.utils/-observable-list",children:(0,i.jsx)(n.code,{children:"ObservableList"})})," of images via ",(0,i.jsx)(n.code,{children:"loadedImages"}),". This list will provide the model state our list uses to render. The model will then fetch paginated images from Unsplash and load the resulting urls asynchronously into this list."]}),"\n",(0,i.jsxs)(n.p,{children:["We track the ",(0,i.jsx)(n.code,{children:"currentPage"})," and ",(0,i.jsx)(n.code,{children:"pageSize"})," to fetch a growing list of pages from Unsplash. We fetch a new page whenever the ",(0,i.jsx)(n.code,{children:"currentPage"})," is updated."]}),"\n",(0,i.jsx)(s.v,{children:"\nclass UnSplashDataModel(private val scope: CoroutineScope, /*...*/): DynamicListModel<Image> {\n    // ...\n\n    private var httpRequestJob: Job? by observable(null) { _,old,_ ->\n        old?.cancel()\n    }\n\n    private var currentPage: Int by observable(-1) { _,_ ->\n        fetchActive    = true\n        httpRequestJob = scope.launch {\n            val results = client.get<List<UnsplashPhoto>>(unsplashLocation)\n\n            loadedImages.addAll(results.mapNotNull { imageLoader.load(it.urls.small) })\n\n            fetchActive = false\n\n            if (nextPageNeeded) {\n                nextPageNeeded  = false\n                currentPage    += 1\n            }\n        }\n    }\n\n    // ...\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["Fetches are performed using Ktor's HttpClient configured to read JSON data. These reads are done via Kotlin Serialization into the ",(0,i.jsx)(n.code,{children:"UnsplashPhoto"})," data class. We only use the ",(0,i.jsx)(n.code,{children:"small"})," value in the ",(0,i.jsx)(n.code,{children:"urls"})," property from the JSON response, so our data classes are much simpler than the full Unsplash API."]}),"\n",(0,i.jsx)(s.v,{children:"\nclass UnSplashDataModel(httpClient: HttpClient, /*...*/): DynamicListModel<Image> {\n    // ...\n\n    @Serializable\n    data class Urls(val small: String)\n\n    @Serializable\n    data class UnsplashPhoto(val id: String, val urls: Urls)\n\n    // HTTP client configured to read JSON  returned from unsplash\n    private val client = httpClient.config {\n        install(JsonFeature) {\n            serializer = KotlinxSerializer(Json { ignoreUnknownKeys = true })\n        }\n    }\n\n    // ...\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"loadedImages"})," list triggers an event whenever we add a new set of images to it. We use this fact to notify of changes to the model, which get reflected by the ",(0,i.jsx)(n.code,{children:"DynamicList"}),"."]}),"\n",(0,i.jsx)(s.v,{children:"\nclass UnSplashDataModel(/*...*/): DynamicListModel<Image> {\n    // ...\n\n    override val changed = SetPool<ModelObserver<Image>>()\n\n    // Internal list used to cache images loaded from unsplash\n    private val loadedImages = ObservableList<Image>().also {\n        it.changed += { _ ,removed, added, moved ->\n            // notify model observers whenever the underlying list changes (due to image loads)\n            changed.forEach {\n                it(this, removed, added, moved)\n            }\n        }\n    }\n\n    // ...\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["Finally, we need to decide when to fetch more images. We do this whenever ",(0,i.jsx)(n.code,{children:"get"})," is called on the last image of the model. This happens when the ",(0,i.jsx)(n.code,{children:"DynamicList"})," needs to present that image, and is a good indication that it has reached the end."]}),"\n",(0,i.jsx)(s.v,{children:"\nclass UnSplashDataModel(/*...*/): DynamicListModel<Image> {\n    // ...\n\n    override fun get(index: Int): Image? = loadedImages.getOrNull(index).also {\n        // Load the next page if the last image is fetched from the model\n        if (index == size - 1) {\n            when {\n                fetchActive -> nextPageNeeded  = true\n                else        -> currentPage    += 1\n            }\n        }\n    }\n\n    // ...\n}\n"}),"\n",(0,i.jsx)(n.h2,{id:"presenting-the-images",children:"Presenting The Images"}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"DynamicList"})," holds a list of ",(0,i.jsx)(n.code,{children:"Image"})," items, but these are not ",(0,i.jsx)(n.code,{children:"View"}),"s. Which means we need a way of visualizing them. Many Doodle containers use this concept of an ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls/-item-visualizer",children:(0,i.jsx)(n.code,{children:"ItemVisualizer"})}),". It is essentially a class that maps from some type ",(0,i.jsx)(n.code,{children:"T"})," to ",(0,i.jsx)(n.code,{children:"View"})," based on a set of inputs. ",(0,i.jsx)(n.code,{children:"DynamicList"})," takes an ",(0,i.jsx)(n.code,{children:"itemVisualizer"})," in its constructor that can be used by is ",(0,i.jsx)(n.code,{children:"behavior"})," to render the contents of each row. Our app uses the ",(0,i.jsx)(n.code,{children:"BasicListBehavior"})," to configure our list. Internally, that behavior takes the list's visualizer and creates a new ",(0,i.jsx)(n.code,{children:"View"})," that is wrapped in another that represents the row itself. So it is sufficient to specify a visualizer that renders our images."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["It is also possible to change the way ",(0,i.jsx)(n.code,{children:"BasicListBehavior"})," (and any ",(0,i.jsx)(n.code,{children:"ListBehavior"}),") represents its rows by specifying it's ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls.theme/-tree-behavior/-row-generator",children:(0,i.jsx)(n.code,{children:"RowGenerator"})}),"."]})}),"\n",(0,i.jsx)(s.v,{children:"\nclass PhotoStreamApp(/*...*/): Application {\n    init {\n        // ...\n\n        val list = DynamicList(\n            model          = UnSplashDataModel(appScope, httpClient, imageLoader),\n            itemVisualizer = itemVisualizer { image, recycledView, _ -> when(recycledView) {\n                is CenterCroppedPhoto -> recycledView.also { recycledView.image = image }\n                else                  -> CenterCroppedPhoto(image)\n            } }\n        ).apply {\n            behavior      = BasicListBehavior(rowHeight = imageHeight)\n            cellAlignment = fill\n        }\n    }\n\n    // ...\n}\n"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ItemVisualizer"})," is designed to support recycling. Each invocation may provide a recycled View that might be reusable for the new item. This lets us reuse the ",(0,i.jsx)(n.code,{children:"CenterCroppedPhoto"})," instances as the list scrolls."]})}),"\n",(0,i.jsxs)(n.p,{children:["We will render each image as with a center-crop using ",(0,i.jsx)(n.code,{children:"CenterCroppedPhoto"}),". This class holds an image that it renders with a centered square crop. The crop square's length is equal to the image's width or height (whichever is smaller). That center region is then scaled to fit the cropped photo View's bounds."]}),"\n",(0,i.jsx)(s.v,{children:d})]})}function v(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);