"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5931],{1387:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>f,contentTitle:()=>g,default:()=>b,frontMatter:()=>m,metadata:()=>o,sourceTree:()=>v,toc:()=>x});const o=JSON.parse('{"id":"timedcards","title":"Timed Cards","description":"TimedCards Tutorial","source":"@site/docs/timedcards.mdx","sourceDirName":".","slug":"/timedcards","permalink":"/doodle-tutorials/docs/timedcards","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Timed Cards","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/doodle-tutorials/docs/introduction"},"next":{"title":"Animating Tab Strip","permalink":"/doodle-tutorials/docs/tabstrip"}}');var r=t(4848),i=t(8453),a=(t(4865),t(9365),t(854)),s=t(9053),l=t(7020);const d="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.accessibility.ImageRole\nimport io.nacular.doodle.controls.carousel.CarouselItem\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.lerp\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.image.width\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.utils.TextAlignment\nimport io.nacular.doodle.utils.observable\nimport kotlin.math.min\n\n/**\n * Data objects that are stored in the Carousel's model. These are converted to [Card]s.\n */\ndata class CardData(val image: Image, val header: String, val title: String, val clip: Rectangle) {\n    val width get() = image.width\n}\n\n/**\n * Represents each item in the Carousel. These are created by the [ItemVisualizer][io.nacular.doodle.controls.ItemVisualizer]\n * passed to the Carousel.\n */\n//sampleStart\nclass Card(\n    private var data           : CardData,\n    private var context        : CarouselItem,\n    private val fonts          : Fonts,\n    private val itemInitialSize: () -> Size,\n): View(accessibilityRole = ImageRole()) {\n\n    private val smallHeader = header(data.header, fonts.smallBoldFont      )\n    private val smallTitle  = title(data.title,   fonts.smallBoldFont, -0.8)\n    private val largeText   = container {\n        + view { render = { rect(bounds.atOrigin, fill = White.paint) } }\n        + header(data.header, fonts.largeRegularFont   )\n        + title (data.title,  fonts.largeBoldFont, -1.0)\n\n        layout = constrain(children[0], children[1], children[2]) { block, header, title ->\n            block.edges eq Rectangle(15, 3)\n\n            header.top  eq block.bottom + 8\n            header.left eq block.left\n            header.width.preserve\n            header.height.preserve\n\n            title.top   eq header.bottom + 7\n            title.left  eq 0\n            title.right eq parent.right\n            title.height.preserve\n\n            parent.height eq title.bottom\n        }\n\n        opacity = 0f\n    }\n\n    private var progress by observable(0f) { _, new ->\n        largeText.opacity = when {\n            new >= 0.5f -> (new - 0.5f) * 2\n            else -> 0f\n        }\n\n        relayout()\n        rerender()\n    }\n\n    init {\n        suggestSize(data.image.size)\n\n        enabled            = false\n        clipCanvasToBounds = false\n\n        children += container {\n            + view { render = { rect(bounds.atOrigin, fill = White.paint) } }\n            + smallHeader\n            + smallTitle\n\n            layout = constrain(children[0], smallHeader, smallTitle) { bar, header, title ->\n                bar.edges eq Rectangle(7.0, 1.5)\n\n                header.top  eq bar.bottom + 6\n                header.left eq bar.left\n                header.width.preserve\n                header.height.preserve\n\n                title.top   eq header.bottom + 7\n                title.left  eq 0\n                title.right eq parent.right\n                title.height.preserve\n\n                parent.bottom eq title.bottom\n            }\n        }\n        children += largeText\n\n        layout = constrain(children[0], children[1]) { smallText, largeText ->\n            smallText.left   eq parent.centerX - itemInitialSize().width / 2 + 10\n            smallText.right  eq parent.right  - 10\n            smallText.bottom eq parent.bottom - 20 + progress * 800\n            smallText.height eq smallText.idealHeight\n\n            val largeTextOffset = when {\n                progress >= 0.5f -> 20 * (1 - (progress - 0.5f) * 2)\n                else             -> 0f\n            }\n\n            largeText.left    eq  50\n            largeText.width   eq 500\n            largeText.height  eq largeText.idealHeight\n            largeText.centerY eq parent.centerY + 5 + largeTextOffset\n        }\n\n        updateProgress()\n    }\n\n    /**\n     * Called when a Card needs to be recycled to display a new [CardData] or [CarouselItem].\n     */\n    fun update(data: CardData, context: CarouselItem) {\n        this.data    = data\n        this.context = context\n\n        updateProgress()\n    }\n\n    override fun render(canvas: Canvas) {\n        val clip   = lerp(data.clip, Rectangle(data.width, data.width * MAIN_ASPECT_RATIO), min(1f, progress * 2f))\n        val radius = 10.0 * (1 - progress * 1.5)\n\n        canvas.outerShadow(blurRadius = 10.0, vertical = 10.0, horizontal = 10.0, color = Black opacity 0.5f) {\n            val w = height * clip.width/clip.height\n\n            image(\n                image       = data.image,\n                source      = clip,\n                radius      = radius,\n                destination = Rectangle((width - w) / 2, 0.0, w, height)\n            )\n        }\n    }\n\n    private fun updateProgress() {\n        progress = when (context.index) {\n            context.nearestItem -> 1f\n            (context.nearestItem + 1) % context.numItems -> context.progressToNextItem\n            else -> 0f\n        }\n    }\n\n    private fun header(text: String, font: Font) = Label(text).apply {\n        this.font     = font\n        letterSpacing = 0.0\n    }\n\n    private fun title(text: String, font: Font, letterSpacing: Double) = Label(text).apply {\n        this.font          = font\n        this.letterSpacing = letterSpacing\n        wrapsWords         = true\n        textAlignment      = TextAlignment.Start\n        lineSpacing        = 1.1f\n    }\n}\n//sampleEnd",c='@file:Suppress("OPT_IN_USAGE")\n\nimport org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_11\n\n\n//sampleStart\nplugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    js     { browser { binaries.executable() } }  // Web     (JS  ) executable\n    wasmJs { browser { binaries.executable() } }  // Web     (WASM) executable\n    jvm    {                                      // Desktop (JVM ) executable\n        compilerOptions { jvmTarget.set(JVM_11) } // JVM 11 is needed for Desktop\n        withJava()\n    }\n\n    sourceSets {\n        // Source set for all platforms\n        commonMain.dependencies {\n            api(libs.coroutines.core ) // async resource loading (fonts, images, ...)\n\n            api(libs.doodle.controls )\n            api(libs.doodle.animation)\n        }\n\n        // Web (JS) platform source set\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        // Web (WASM) platform source set\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.doodle.browser)\n            }\n        }\n\n        // Desktop (JVM) platform source set\n        jvmMain.dependencies {\n            // helper to derive OS/architecture pair\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n    }\n}\n\n// Desktop entry point\napplication {\n    mainClass.set("MainKt")\n}\n//sampleEnd\n\n// could be moved to buildSrc, but kept here for clarity\nfun osTarget(): String {\n    val osName = System.getProperty("os.name")\n    val targetOs = when {\n        osName == "Mac OS X"       -> "macos"\n        osName.startsWith("Win"  ) -> "windows"\n        osName.startsWith("Linux") -> "linux"\n        else                       -> error("Unsupported OS: $osName")\n    }\n\n    val targetArch = when (val osArch = System.getProperty("os.arch")) {\n        "x86_64", "amd64" -> "x64"\n        "aarch64"         -> "arm64"\n        else              -> error("Unsupported arch: $osArch")\n    }\n\n    return "${targetOs}-${targetArch}"\n}',h="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.animation.Animator\nimport io.nacular.doodle.animation.invoke\nimport io.nacular.doodle.animation.transition.easeInOutCubic\nimport io.nacular.doodle.animation.tweenFloat\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.carousel.Carousel\nimport io.nacular.doodle.controls.carousel.CarouselBehavior\nimport io.nacular.doodle.controls.carousel.dampedTransitioner\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.event.KeyCode.Companion.ArrowLeft\nimport io.nacular.doodle.event.KeyCode.Companion.ArrowRight\nimport io.nacular.doodle.event.KeyListener.Companion.pressed\nimport io.nacular.doodle.event.PointerListener.Companion.on\nimport io.nacular.doodle.event.PointerMotionListener.Companion.dragged\nimport io.nacular.doodle.focus.FocusManager\nimport io.nacular.doodle.geometry.Point.Companion.Origin\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Strong\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.scheduler.AnimationScheduler\nimport io.nacular.doodle.theme.Theme\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.time.Timer\nimport io.nacular.measured.units.Time.Companion.seconds\nimport io.nacular.measured.units.times\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.cancel\nimport kotlinx.coroutines.launch\n\n//sampleStart\nclass TimedCardsApp(\n                display     : Display,\n                focusManager: FocusManager,\n                themeManager: ThemeManager,\n                theme       : Theme,\n    private val fonts       : FontLoader,\n    private val images      : ImageLoader,\n    private val timer       : Timer,\n    private val animate     : Animator,\n    private val textMetrics : TextMetrics,\n    private val scheduler   : AnimationScheduler,\n                uiDispatcher: CoroutineDispatcher,\n): Application {\n\n    private val appScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n\n    private lateinit var appFonts: Fonts\n    private lateinit var carousel: Carousel<CardData, *>\n\n    init {\n        appScope.launch(uiDispatcher) {\n            themeManager.selected = theme\n\n            appFonts = loadFonts(fonts)\n\n            // Carousel containing all the content\n            carousel = Carousel(\n                createModel(images),\n                itemVisualizer { item, previous, context ->\n                    when (previous) {\n                        is Card -> previous.apply { update(item, context) }\n                        else    -> Card(item, context, appFonts) { itemSize(carousel.size) }\n                    }\n                }\n            ).apply {\n                wrapAtEnds = true\n                behavior   = object: CarouselBehavior<CardData> {\n                    // Presenter controlling which items are shown and how they adjust\n                    // as the Carousel moves between frames.\n                    override val presenter = CardPresenter<CardData> { itemSize(it) }\n\n                    // Responsible for automatic movement between frames\n                    override val transitioner = dampedTransitioner<CardData>(timer, scheduler) { _,_,_, update ->\n                        animate(0f to 1f, using = tweenFloat(easeInOutCubic, duration = 1.25 * seconds)) {\n                            update(it)\n                        }\n                    }\n                }\n\n                keyChanged += pressed {\n                    when (it.code) {\n                        ArrowLeft  -> previous() // Move Carousel back one\n                        ArrowRight -> next    () // Move Carousel forward one\n                    }\n                }\n\n                var touchLocation = Origin\n\n                // start/stop manual movement of the Carousel on pointer press/release\n                pointerChanged += on(\n                    pressed  = {\n                        touchLocation = toLocal(it.location, it.target)\n                        startManualMove()\n                        it.consume()\n                    },\n                    released = { completeManualMove() },\n                )\n\n                // perform manual movement of the Carousel\n                pointerMotionChanged += dragged {\n                    if (it.source == this) {\n                        moveManually(toLocal(it.location, it.target) - touchLocation)\n                        it.consume()\n                    }\n                }\n            }\n\n            val buttonControls = ButtonControls(carousel, textMetrics, appFonts)\n\n            display += carousel\n            display += buttonControls\n\n            display.layout = constrain(carousel, display.children[1]) { carousel_, controls ->\n                carousel_.width  eq     CAROUSEL_MAX_WIDTH strength Strong\n                carousel_.height eq     carousel_.width  * MAIN_ASPECT_RATIO\n                carousel_.width  eq     carousel_.height / MAIN_ASPECT_RATIO\n\n                carousel_.width  lessEq parent.width\n                carousel_.height lessEq parent.height\n                carousel_.center eq     parent.center\n\n                controls.left    eq     carousel_.left + (carousel_.width - itemSize(carousel.size).width) / 2\n                controls.height  eq     CONTROLS_HEIGHT\n                controls.right   eq     carousel_.right\n                controls.bottom  eq     carousel_.bottom\n            }\n\n            focusManager.requestFocus(carousel)\n        }\n    }\n\n    override fun shutdown() {\n        appScope.cancel()\n    }\n}\n//sampleEnd",p="package io.nacular.doodle.examples\n\nimport io.nacular.doodle.controls.carousel.Carousel\nimport io.nacular.doodle.controls.carousel.CarouselBehavior\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.geometry.Vector2D\nimport io.nacular.doodle.geometry.lerp\nimport io.nacular.doodle.layout.Insets\nimport kotlin.math.abs\nimport kotlin.math.min\n\n/**\n * Presenter responsible for displaying the contents of the Carousel\n */\n//sampleStart\nclass CardPresenter<T>(private val spacing: Double = 20.0, private val itemSize: (Size) -> Size): CarouselBehavior.Presenter<T>() {\n    /**\n     * Determines what is shown in the Carousel\n     */\n    override fun present(\n        carousel         : Carousel<T, *>,\n        position         : Position,\n        progressToNext   : Float,\n        supplementalViews: List<View>,\n        items            : (at: Position) -> Carousel.PresentedItem?\n    ): Presentation {\n        var zOrder          = 0\n        val results         = mutableListOf<Carousel.PresentedItem>()\n        val itemSize        = itemSize(carousel.size)\n        var currentBounds   = null as Rectangle?\n        var currentPosition = position as Position?\n        val mainBounds      = Rectangle(carousel.size).inset(-10.0)\n\n        // Add selected card\n        currentPosition?.let(items)?.let {\n            // Image is outset by 10, and grows as we progress to the next frame\n            it.bounds       = mainBounds.inset(Insets(-progressToNext * itemSize.width * 0.5))\n            it.zOrder       = zOrder++\n            currentPosition = currentPosition.next\n\n            results += it\n        }\n\n        // Add the first small card\n        currentPosition?.let(items)?.let { item ->\n            // bounds when exactly at frame\n            val bounds = Rectangle(\n                Point(\n                    (carousel.width - itemSize.width) / 2,\n                    (carousel.height - itemSize.height - CONTROLS_HEIGHT)\n                ),\n                itemSize\n            )\n\n            // bounds gradually grows toward main bounds\n            item.bounds = lerp(bounds, mainBounds, min(1f, progressToNext * 2))\n\n            // increase item zOrder so they sort properly\n            item.zOrder = zOrder++\n\n            // next item is shifted over towards this slot as progress increases\n            currentBounds   = bounds.run { at(x - progressToNext * (width + spacing)) }\n            currentPosition = currentPosition.next\n\n            results += item\n        }\n\n        // add the remaining cards to the right of the first small one\n        do {\n            currentPosition?.let(items)?.let { item ->\n                // each item is offset to the right of the second, with a spacing that varies w/ progress\n                currentBounds = currentBounds?.run {\n                    at(right + spacing + -abs(progressToNext - 0.5f) * 3 * spacing + 3 * spacing / 2)\n                }\n\n                currentBounds?.let { item.bounds = it }\n\n                // increase item zOrder so they sort properly\n                item.zOrder = zOrder++\n\n                results += item\n            } ?: break\n        } while (\n            // continue until there are no more items to show\n            (currentBounds?.right ?: 0.0) + spacing < carousel.size.width &&\n            currentPosition.next?.also { currentPosition = it } != null\n        )\n\n        return Presentation(items = results)\n    }\n\n    override fun distanceToNext(\n        carousel: Carousel<T, *>,\n        position: Position,\n        offset  : Vector2D,\n        items   : (Position) -> Carousel.PresentedItem?\n    ): Distance = Distance(Vector2D(x = 1), carousel.width)\n}\n//sampleEnd",u='package io.nacular.doodle.examples\n\nimport io.nacular.doodle.controls.buttons.Button\nimport io.nacular.doodle.controls.buttons.PushButton\nimport io.nacular.doodle.controls.carousel.Carousel\nimport io.nacular.doodle.controls.theme.CommonButtonBehavior\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.view\nimport io.nacular.doodle.drawing.AffineTransform\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Circle\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.inscribed\nimport io.nacular.doodle.geometry.inset\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.system.Cursor.Companion.Pointer\nimport io.nacular.measured.units.Angle\nimport io.nacular.measured.units.times\nimport kotlin.math.min\n\nclass ButtonControls(carousel: Carousel<*, *>, textMetrics: TextMetrics, private val fonts: Fonts): View() {\n\n    private val stroke = Stroke(White opacity 0.75f, 0.5)\n\n    // Let pointer pass through everywhere else\n    override fun contains(point: Point) = (point - position).let { localPoint -> children.any { it.contains(localPoint) } }\n\n    init {\n        //sampleStart\n        children += leftButton  { carousel.previous() } // Skip to the previous frame\n        children += rightButton { carousel.next    () } // Skip to the next frame\n\n        // Progress Bar\n        children += view {\n            contains = { false }\n            render   = {\n                val progress = (carousel.nearestItem + carousel.progressToNextItem) / carousel.numItems\n\n                rect(bounds.atOrigin,                     fill = stroke.fill           )\n                rect(Rectangle(progress * width, height), fill = Color(0xE8B950u).paint)\n            }\n\n            carousel.progressChanged += { rerender() }\n        }\n\n        // Frame Number\n        children += view {\n            font     = fonts.mediumBoldFont\n            contains = { false }\n            render   = {\n                val currentIndex = "0${(carousel.nearestItem    ) % carousel.numItems + 1}"\n                val nextIndex    = "0${(carousel.nearestItem + 1) % carousel.numItems + 1}"\n                val size1        = textMetrics.size(currentIndex, font)\n                val size2        = textMetrics.size(nextIndex,    font)\n\n                val x1 = (width  - size1.width ) / 2 - carousel.progressToNextItem * width\n                val y1 = (height - size1.height) / 2\n                val x2 = (width  - size2.width ) / 2 - carousel.progressToNextItem * width + width\n                val y2 = (height - size2.height) / 2\n\n                text(currentIndex, at = Point(x1, y1), font = font, fill = White.paint)\n                text(nextIndex,    at = Point(x2, y2), font = font, fill = White.paint)\n            }\n\n            carousel.progressChanged += { rerender() }\n        }\n//sampleEnd\n\n        layout = constrain(children[0], children[1], children[2], children[3]) { left, right, progress, text ->\n            left.left        eq 0\n            left.width       eq left.height\n            left.height      eq 45\n            left.centerY     eq parent.centerY\n\n            right.left       eq left.right + 10\n            right.width      eq left.width\n            right.height     eq left.height\n            right.centerY    eq left.centerY\n\n            progress.left    eq right.right   + 20\n            progress.right   eq text.left - 20\n            progress.height  eq 1.5\n            progress.centerY eq right.centerY\n\n            text.top         eq 0\n            text.width       eq 40\n            text.right       eq parent.right - 20\n            text.height      eq parent.height\n        }\n    }\n\n    private fun leftButton (onFired: (Button) -> Unit) = skipButton(isRightButton = false, onFired)\n    private fun rightButton(onFired: (Button) -> Unit) = skipButton(isRightButton = true,  onFired)\n\n    private fun skipButton(isRightButton: Boolean, onFired: (Button) -> Unit) = PushButton().apply {\n        font          = fonts.smallRegularFont\n        fired        += onFired\n        cursor        = Pointer\n        behavior      = buttonRenderer(right = isRightButton)\n        acceptsThemes = false\n\n        return this\n    }\n\n    private fun buttonRenderer(right: Boolean = true) = object: CommonButtonBehavior<Button>(null) {\n        override fun contains(view: Button, point: Point): Boolean =\n            point in Circle(view.bounds.center, min(view.width, view.height) / 2)\n\n        override fun render(view: Button, canvas: Canvas) {\n            val circle   = Circle(view.bounds.atOrigin.center, min(view.width, view.height) / 2)\n            val triangle = AffineTransform.Identity.scale(around = circle.center, x = 0.7)(circle.inset(circle.radius * 0.75).inscribed(\n                3,\n                if (right) 90 * Angle.degrees else 270 * Angle.degrees\n            )!!)\n\n            val points = listOf(triangle.points[2], triangle.points[0], triangle.points[1])\n\n            canvas.circle(circle.inset(stroke.thickness / 2), stroke = stroke)\n            canvas.path  (points, Stroke(stroke.fill, 4 * stroke.thickness))\n        }\n    }\n}\n',m={title:"Timed Cards",hide_title:!0},g=void 0,f={},v=(0,l.a)([{label:"src",children:[{label:"commonMain",children:[{label:"kotlin"}]},{label:"jsMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jvmMain",children:[{label:"kotlin"}]},{label:"wasmJsMain",children:[{label:"kotlin"},{label:"resources"}]}]},{label:"build.gradle.kts"}]),x=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"The Card Presenter",id:"the-card-presenter",level:2},{value:"Transitioner",id:"transitioner",level:2},{value:"Carousel Interactions",id:"carousel-interactions",level:2},{value:"Cards",id:"cards",level:2}];function w(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("h1",{children:(0,r.jsx)("a",{class:"inline-github-link",href:"https://github.com/nacular/doodle-tutorials/tree/master/TimedCards",target:"_blank",children:"TimedCards Tutorial"})}),"\n",(0,r.jsxs)(n.p,{children:["This is a simple app that shows the flexibility of Doodle Carousels. It is inspired by ",(0,r.jsx)(n.a,{href:"https://dribbble.com/shots/11012652--Timed-Cards-Opening",children:'Giulio Cuscito\'s "Timed Cards Opening"'}),". This app is multi-platform, which means it will run in the browser and as a desktop application."]}),"\n",(0,r.jsxs)(n.p,{children:["The entire app rests on ",(0,r.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#carousel",children:"Doodle's powerful Carousel APIs"})," to create the layout and smooth, perfectly-timed transitions."]}),"\n",(0,r.jsx)(s.I,{function:"timedCards",height:"538.875"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["You can also see the full-screen app here: ",(0,r.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/timedcards",children:"JavaScript"}),", ",(0,r.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/timedcards_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,r.jsx)(n.p,{children:"The app will use a Kotlin Multiplatform setup, which means we can run it on a range of targets supported by Doodle. The directory structure follows a fairly common layout, with common classes and resources in one source set and platform-specific items in their own."}),"\n","\n",(0,r.jsx)(n.admonition,{title:"Directory Layout",type:"info",children:(0,r.jsxs)(l.k,{items:v,defaultExpandedItems:["src","src/commonMain"],defaultSelectedItem:"src",children:[(0,r.jsxs)("div",{value:"src",children:[(0,r.jsxs)(n.p,{children:["All source code and resources are located under the ",(0,r.jsx)(n.code,{children:"src"})," directory."]}),(0,r.jsxs)(n.p,{children:["The application logic itself is located in the common source set (",(0,r.jsx)(n.code,{children:"src/commonMain"}),"), which means it is entirely reused for each platform. In fact, the same app is used unchanged (just targeting JS) within this documentation."]})]}),(0,r.jsx)("div",{value:"src/commonMain",children:(0,r.jsxs)(n.p,{children:["Source code and resources for that are usable for platforms are stored in ",(0,r.jsx)(n.code,{children:"commonMain"}),". This app is designed to work on all platforms, so our app code and all logic is found under this directory."]})}),(0,r.jsxs)("div",{value:"src/commonMain/kotlin",children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"kotlin"})," directory is where all code for a platform resides. In this case, we have all the classes for our app, including ",(0,r.jsx)(n.code,{children:"TimedCardsApp"}),", ",(0,r.jsx)(n.code,{children:"Card"}),", ",(0,r.jsx)(n.code,{children:"CardPresenter"}),", ",(0,r.jsx)(n.code,{children:"ButtonControls"})," and ",(0,r.jsx)(n.code,{children:"Utils"}),"."]}),(0,r.jsx)(n.p,{children:"All of these classes are platform agnostic and used by all targets. This makes our app work on any target Doodle supports."})]}),(0,r.jsx)("div",{value:"src/jsMain",children:(0,r.jsxs)(n.p,{children:["Source code and resources that are needed for Web (JS) target are stored in ",(0,r.jsx)(n.code,{children:"jsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,r.jsx)("div",{value:"src/jsMain/kotlin",children:(0,r.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,r.jsx)(n.code,{children:"main"})," function."]})}),(0,r.jsx)("div",{value:"src/jsMain/resources",children:(0,r.jsxs)(n.p,{children:["Holds the ",(0,r.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (JS) target."]})}),(0,r.jsx)("div",{value:"src/jvmMain",children:(0,r.jsxs)(n.p,{children:["Source code and resources that are needed for Desktop (JVM) target are stored in ",(0,r.jsx)(n.code,{children:"jvmMain"}),"."]})}),(0,r.jsx)("div",{value:"src/jvmMain/kotlin",children:(0,r.jsxs)(n.p,{children:["The Desktop launch portion of our app is located here in the program's ",(0,r.jsx)(n.code,{children:"main"})," function."]})}),(0,r.jsx)("div",{value:"src/wasmJsMain",children:(0,r.jsxs)(n.p,{children:["Source code and resources that are needed for Web (WASM) target are stored in ",(0,r.jsx)(n.code,{children:"wasmJsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,r.jsx)("div",{value:"src/wasmJsMain/kotlin",children:(0,r.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,r.jsx)(n.code,{children:"main"})," function."]})}),(0,r.jsx)("div",{value:"src/wasmJsMain/resources",children:(0,r.jsxs)(n.p,{children:["Holds the ",(0,r.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (WASM) target."]})}),(0,r.jsx)("div",{value:"build.gradle.kts",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"build.gradle.kts"})," file defines how the app is configured and all its dependencies. The TimedCards app uses a multi-platform configuration so it can run on all Doodle supported targets."]})})]})}),"\n",(0,r.jsxs)(n.p,{children:["Doodle apps are built using gradle like other Kotlin apps. The build is controlled by the ",(0,r.jsx)(n.code,{children:"build.gradle.kts"})," script in the root of the ",(0,r.jsx)(n.code,{children:"TimedCards"})," directory."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"build.gradle.kts"})}),"\n",(0,r.jsx)(a.v,{children:c}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The gradle build uses ",(0,r.jsx)(n.a,{href:"https://docs.gradle.org/current/userguide/version_catalogs.html",children:"gradle version catalogs"}),"; see ",(0,r.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file for library info."]})}),"\n",(0,r.jsx)(n.h2,{id:"the-application",children:"The Application"}),"\n",(0,r.jsxs)(n.p,{children:["All Doodle apps must implement the ",(0,r.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:(0,r.jsx)(n.code,{children:"Application"})})," interface. The framework will then initialize our app via the constructor. Our app will be fairly simple: just create an instance of our calculator and add it to the display."]}),"\n",(0,r.jsxs)(n.p,{children:["Doodle apps can be defined in ",(0,r.jsx)(n.code,{children:"commonMain"}),", since they do not require any platform-specific dependencies (we will do this as well). They can also be ",(0,r.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. Use the ",(0,r.jsx)(n.code,{children:"application"})," function in a platform source-set (i.e. ",(0,r.jsx)(n.code,{children:"jsMain"}),", ",(0,r.jsx)(n.code,{children:"jvmMain"}),", etc.) to launch top-level apps. It takes a list of modules to load and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,r.jsx)(n.code,{children:"instance"}),", ",(0,r.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/TimedCards/src/commonMain/kotlin/io/nacular/doodle/examples/TimedCardsApp.kt#L43",children:(0,r.jsx)(n.strong,{children:"TimedCardsApp.kt"})})}),"\n",(0,r.jsx)(a.v,{children:h}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Notice that ",(0,r.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,r.jsx)(n.h2,{id:"the-card-presenter",children:"The Card Presenter"}),"\n",(0,r.jsxs)(n.p,{children:["This app has a single Carousel that contains almost all of the UI elements. And that Carousel is driven by a custom ",(0,r.jsx)(n.code,{children:"Presenter"})," that manages the layout and animation of the cards within it."]}),"\n",(0,r.jsx)(n.p,{children:"The cards in the Carousel can be in 3 key positions. The first position is that of the selected card, which fills the Carousel and has larger text displayed to the left. The first small card is in the second important position. And the cards to the right of the first card a all in the last key position."}),"\n",(0,r.jsxs)(n.p,{children:["The second position is treated as special because it has to support the transition from small to large card. Therefore the ",(0,r.jsx)(n.code,{children:"CardPresenter"})," needs to track it directly."]}),"\n",(0,r.jsx)(a.v,{children:p}),"\n",(0,r.jsx)(n.p,{children:"This presenter is all it takes to handle all the positioning for the Carousel's contents."}),"\n",(0,r.jsx)(n.h2,{id:"transitioner",children:"Transitioner"}),"\n",(0,r.jsx)(n.p,{children:"Carousel's also expose a way to manage their automatic movement between frames. This includes changing frames or when a manual move is completed and the Carousel needs to move to a valid frame."}),"\n",(0,r.jsxs)(n.p,{children:["This app uses the ",(0,r.jsx)(n.code,{children:"DampedTransitioner"})," with an animation for auto frame selection. This Transitioner provides a critically damped spring behavior to smoothly complete manual movement (which happens after a swipe for example). And the animation provided by our app is used during frame jumps."]}),"\n",(0,r.jsx)(a.v,{children:"\nbehavior = object: CarouselBehavior<CardData> {\n  override val presenter = CardPresenter<CardData> { itemSize(it) }\n\n  override val transitioner = dampedTransitioner<CardData>(timer, scheduler) { _,_,_, update ->\n      animate(0f to 1f, using = tweenFloat(easeInOutCubic, duration = 1.25 * seconds)) {\n          update(it)\n      }\n  }\n}\n"}),"\n",(0,r.jsx)(n.h2,{id:"carousel-interactions",children:"Carousel Interactions"}),"\n",(0,r.jsxs)(n.p,{children:["The app uses a floating View with controls to interact with the Carousel and monitor its progress. The two buttons trigger ",(0,r.jsx)(n.code,{children:"Carousel.previous()"})," and ",(0,r.jsx)(n.code,{children:"Carousel.next()"})," to switch back and forth between frames. While the progress bar and frame text listen for ",(0,r.jsx)(n.code,{children:"Carousel.progressChanged"})," and update accordingly."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Button Controls"})}),"\n",(0,r.jsx)(a.v,{children:u}),"\n",(0,r.jsx)(n.h2,{id:"cards",children:"Cards"}),"\n",(0,r.jsx)(n.p,{children:"The cards shown in the Carousel are very dynamic and change what they show when moving from their small to large size."}),"\n",(0,r.jsx)(a.v,{children:d})]})}function b(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(w,{...e})}):w(e)}}}]);