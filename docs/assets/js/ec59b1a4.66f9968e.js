"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8461],{5379:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>f,frontMatter:()=>h,metadata:()=>i,sourceTree:()=>m,toc:()=>b});const i=JSON.parse('{"id":"contacts","title":"Contacts","description":"Contacts Tutorial","source":"@site/docs/contacts.mdx","sourceDirName":".","slug":"/contacts","permalink":"/doodle-tutorials/docs/contacts","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Contacts","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Animating Tab Strip","permalink":"/doodle-tutorials/docs/tabstrip"},"next":{"title":"Calculator","permalink":"/doodle-tutorials/docs/calculator"}}');var a=t(4848),o=t(8453),s=(t(4865),t(9365),t(854)),r=t(9053),l=t(7020);const c='@file:Suppress("OPT_IN_USAGE")\n\nimport org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_11\n\n\n//sampleStart\nplugins {\n    kotlin("multiplatform"          )\n    alias(libs.plugins.serialization)\n    application\n}\n\nkotlin {\n    js     { browser { binaries.executable() } }  // Web     (JS  ) executable\n    wasmJs { browser { binaries.executable() } }  // Web     (WASM) executable\n    jvm    {                                      // Desktop (JVM ) executable\n        compilerOptions { jvmTarget.set(JVM_11) } // JVM 11 is needed for Desktop\n        withJava()\n    }\n\n    sourceSets {\n        // Source set for all platforms\n        commonMain.dependencies {\n            api(libs.coroutines.core   ) // async resource loading (fonts, images, ...)\n            api(libs.serialization.json) // persisting contacts\n            api(libs.kodein.di         ) // custom modules\n\n            api(libs.doodle.themes   )\n            api(libs.doodle.controls )\n            api(libs.doodle.animation)\n        }\n\n        // Web (JS) platform source set\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        // Web (WASM) platform source set\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.kotlinx.browser) // Browser APIs for WASM\n\n                implementation(libs.doodle.browser)\n            }\n        }\n\n        // Desktop (JVM) platform source set\n        jvmMain.dependencies {\n            // helper to derive OS/architecture pair\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n    }\n}\n\n// Desktop entry point\napplication {\n    mainClass.set("io.nacular.doodle.example.MainKt")\n}\n//sampleEnd\n\n// could be moved to buildSrc, but kept here for clarity\nfun osTarget(): String {\n    val osName = System.getProperty("os.name")\n    val targetOs = when {\n        osName == "Mac OS X"       -> "macos"\n        osName.startsWith("Win"  ) -> "windows"\n        osName.startsWith("Linux") -> "linux"\n        else                       -> error("Unsupported OS: $osName")\n    }\n\n    val targetArch = when (val osArch = System.getProperty("os.arch")) {\n        "x86_64", "amd64" -> "x64"\n        "aarch64"         -> "arm64"\n        else              -> error("Unsupported arch: $osArch")\n    }\n\n    return "${targetOs}-${targetArch}"\n}',d='@file:Suppress("LocalVariableName")\n\npackage io.nacular.doodle.examples.contacts\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.panels.ScrollPanel\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Strong\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.theme.adhoc.DynamicTheme\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.launch\n\n/**\n * Simple contacts app based on https://phonebook-pi.vercel.app/\n *\n * @param theme for the app\n * @param Header factory for creating the [Header] view\n * @param router for managing app routes\n * @param config creation for the app\n * @param display where all content for the app is shown\n * @param contacts data model\n * @param appScope for launching coroutines\n * @param navigator to show different views within the app\n * @param ContactView factory\n * @param ContactList factory\n * @param uiDispatcher allows dispatching to the UI thread\n * @param themeManager for setting the app\'s theme\n * @param CreateButton factory to obtain the app\'s create button\n * @param EditContactView factory to create the Contact edit view\n * @param CreateContactView factory to create the Contact creation view\n */\nclass ContactsApp(\n    theme            : DynamicTheme,\n    Header           : (AppConfig) -> Header,\n    router           : Router,\n    config           : suspend () -> AppConfig,\n    display          : Display,\n    contacts         : ContactsModel,\n    appScope         : CoroutineScope,\n    navigator        : Navigator,\n    ContactView      : (AppConfig, Contact) -> ContactView,\n    ContactList      : (AppConfig         ) -> ContactList,\n    uiDispatcher     : CoroutineDispatcher,\n    themeManager     : ThemeManager,\n    CreateButton     : (AppConfig         ) -> CreateContactButton,\n    EditContactView  : (AppConfig, Contact) -> EditContactView,\n    CreateContactView: (AppConfig         ) -> CreateContactView,\n): Application {\n\n    private lateinit var header     : Header\n    private lateinit var contactList: View\n\n//sampleStart\n    init {\n        // Coroutine used to load config\n        appScope.launch(uiDispatcher) {\n            themeManager.selected = theme // Install theme\n\n            val appConfig = config() // load app configuration\n\n            header        = Header     (appConfig)\n            contactList   = ContactList(appConfig)\n\n            // Register handlers for different routes\n            router[""                 ] = { _,_        -> setMainView(display, contactList                              ) }\n            router["/add"             ] = { _,_        -> setMainView(display, scrollPanel(CreateContactView(appConfig))) }\n            router["/contact/([0-9]+)"] = { _, matches ->\n                when (val contact = matches.firstOrNull()?.toInt()?.let { contacts.find(it) }) {\n                    null -> navigator.showContactList()\n                    else -> setMainView(display, scrollPanel(ContactView(appConfig, contact)))\n                }\n            }\n            router["/contact/([0-9]+)/edit"] = { _, matches ->\n                when (val contact = matches.firstOrNull()?.toInt()?.let { contacts.find(it) }) {\n                    null -> navigator.showContactList()\n                    else -> setMainView(display, scrollPanel(EditContactView(appConfig, contact)))\n                }\n            }\n\n            display += header\n\n            // Happens after header is added to ensure view goes below create button\n            router.fireAction()\n\n            // Reset layout whenever display children change since the layout stores the display\'s children internally.\n            display.childrenChanged += { _,_ ->\n                updateLayout(display, appConfig)\n            }\n\n            display += CreateButton(appConfig)\n\n            display.fill(appConfig.background.paint)\n        }\n    }\n//sampleEnd\n\n    private fun scrollPanel(content: View) = ScrollPanel(content).apply {\n        contentWidthConstraints  = { it eq width - verticalScrollBarWidth }\n        contentHeightConstraints = { it eq it.idealValue                  }\n    }\n\n    private fun setMainView(display: Display, view: View) {\n        when {\n            display.children.size < 3 -> display             += view\n            else                      -> display.children[1]  = view\n        }\n\n        header.searchEnabled = view == contactList\n    }\n\n    private fun updateLayout(display: Display, appAssets: AppConfig) {\n        display.layout = if (display.children.size < 3) null else constrain(header, display.children[1], display.children[2]) { header_, mainView, button ->\n            header_.top     eq 0\n            header_.width   eq parent.width\n            header_.height  eq header_.idealHeight\n\n            mainView.top    eq header_.height\n            mainView.left   eq INSET\n            mainView.width  eq header_.width - 2 * INSET\n            mainView.bottom eq parent.bottom\n\n            lateinit var buttonSize: Size\n\n            when {\n                header.filterCentered -> {\n                    buttonSize = appAssets.createButtonLargeSize\n                    button.top eq (header.naturalHeight - buttonSize.height) / 2\n                }\n                else                  -> {\n                    buttonSize = appAssets.createButtonSmallSize\n                    button.bottom eq parent.bottom - 40\n                }\n            }\n\n            button.left  greaterEq 20\n            button.right eq        parent.right - 20 strength Strong\n            button.size  eq        buttonSize\n        }\n    }\n\n    override fun shutdown() { /* no-op */ }\n}',h={title:"Contacts",hide_title:!0},p=void 0,u={},m=(0,l.a)([{label:"src",children:[{label:"commonMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jsMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jvmMain",children:[{label:"kotlin"}]},{label:"wasmJsMain",children:[{label:"kotlin"},{label:"resources"}]}]},{label:"build.gradle.kts"}]),b=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"Async Assets",id:"async-assets",level:3},{value:"Theming",id:"theming",level:3},{value:"Routing",id:"routing",level:3},{value:"Responsive Layout",id:"responsive-layout",level:3},{value:"Main Views",id:"main-views",level:2},{value:"Header",id:"header",level:3},{value:"FilterBox",id:"filterbox",level:4},{value:"Contact List",id:"contact-list",level:3},{value:"Custom Table Behavior",id:"custom-table-behavior",level:4},{value:"Contact Creation",id:"contact-creation",level:3},{value:"Contact View",id:"contact-view",level:3},{value:"Contact Editing",id:"contact-editing",level:3}];function g(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("h1",{children:(0,a.jsx)("a",{class:"inline-github-link",href:"https://github.com/nacular/doodle-tutorials/tree/master/Contacts",target:"_blank",children:"Contacts Tutorial"})}),"\n",(0,a.jsxs)(n.p,{children:["This tutorial shows how you might build a simple app to track a list of contacts, each with a name and phone number. It is inspired by ",(0,a.jsx)(n.a,{href:"https://phonebook-pi.vercel.app/",children:"phonebook-pi.vercel.app"}),", which was built using React."]}),"\n",(0,a.jsx)(n.p,{children:"The app is multiplatform and is initialized with different dependencies based on the hosting situation. For example, the one embedded in these docs does not support deep linking, as the router used is a memory only implementation. The full screen, Web version does support deep links though. This works seamlessly, as the app itself is unaware of the implementation details of its dependencies."}),"\n",(0,a.jsx)(r.I,{function:"contacts",height:"590"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["You can also see the full-screen apps here: ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/contacts",children:"JavaScript"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/contacts_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,a.jsx)(n.p,{children:"The app will use a Kotlin Multiplatform setup, which means we can run it on a range of targets supported by Doodle. The directory structure follows a fairly common layout, with common classes and resources in one source set and platform-specific items in their own."}),"\n","\n",(0,a.jsx)(n.admonition,{title:"Directory Layout",type:"info",children:(0,a.jsxs)(l.k,{items:m,defaultExpandedItems:["src","src/commonMain"],defaultSelectedItem:"src",children:[(0,a.jsxs)("div",{value:"src",children:[(0,a.jsxs)(n.p,{children:["All source code and resources are located under the ",(0,a.jsx)(n.code,{children:"src"})," directory."]}),(0,a.jsxs)(n.p,{children:["The application logic itself is located in the common source set (",(0,a.jsx)(n.code,{children:"src/commonMain"}),"), which means it is entirely reused for each platform. In fact, the same app is used unchanged (just targeting JS) within this documentation."]})]}),(0,a.jsx)("div",{value:"src/commonMain",children:(0,a.jsxs)(n.p,{children:["Source code and resources for that are usable for platforms are stored in ",(0,a.jsx)(n.code,{children:"commonMain"}),". This app is designed to work on all platforms, so our app code and all logic is found under this directory."]})}),(0,a.jsxs)("div",{value:"src/commonMain/kotlin",children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"kotlin"})," directory is where all code for a platform resides. In this case, we have all the classes for our app including ",(0,a.jsx)(n.code,{children:"ContactsApp"}),", ",(0,a.jsx)(n.code,{children:"ContactsList"}),", ",(0,a.jsx)(n.code,{children:"ContactListBehavior"}),", ",(0,a.jsx)(n.code,{children:"ContactsModel"}),", etc.. All of these classes are platform agnostic and used by all targets. This makes our app work on any target Doodle supports."]}),(0,a.jsxs)(n.p,{children:["There are also a couple interfaces that need platform-specific implementations that are defined here: ",(0,a.jsx)(n.code,{children:"PersistentStore"})," and ",(0,a.jsx)(n.code,{children:"Router"}),". This allows our app to work with them in a platform independent way, even if they will vary depending on the target it is run on."]})]}),(0,a.jsxs)("div",{value:"src/commonMain/resources",children:[(0,a.jsx)(n.p,{children:"An app can have resources like fonts, images, etc. that it loads at runtime. This directory contains these resources."}),(0,a.jsx)(n.p,{children:"In our case, we will be loading two images and some fonts that we store here."})]}),(0,a.jsx)("div",{value:"src/jsMain",children:(0,a.jsxs)(n.p,{children:["Source code and resources that are needed for Web (JS) target are stored in ",(0,a.jsx)(n.code,{children:"jsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,a.jsx)("div",{value:"src/jsMain/kotlin",children:(0,a.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,a.jsx)(n.code,{children:"main"})," function. The JS version uses a platform-specific ",(0,a.jsx)(n.code,{children:"LocalStorePersistence"})," that is based on the browser's ",(0,a.jsx)(n.code,{children:"LocalStorage"}),". It also have a ",(0,a.jsx)(n.code,{children:"TrivialRouter"})," that uses ",(0,a.jsx)(n.code,{children:"window.location.hash"})," to track/update routes."]})}),(0,a.jsx)("div",{value:"src/jsMain/resources",children:(0,a.jsxs)(n.p,{children:["Holds the ",(0,a.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (JS) target."]})}),(0,a.jsx)("div",{value:"src/jvmMain",children:(0,a.jsxs)(n.p,{children:["Source code and resources that are needed for Desktop (JVM) target are stored in ",(0,a.jsx)(n.code,{children:"jvmMain"}),"."]})}),(0,a.jsx)("div",{value:"src/jvmMain/kotlin",children:(0,a.jsxs)(n.p,{children:["The Desktop launch portion of our app is located here in the program's ",(0,a.jsx)(n.code,{children:"main"})," function. This version uses a platform-specific ",(0,a.jsx)(n.code,{children:"FilePersistence"})," that is based on the file system via ",(0,a.jsx)(n.code,{children:"java.io.File"}),". It also has an ",(0,a.jsx)(n.code,{children:"InMemoryRouter"})," that uses a hashmap internally to track/update routes."]})}),(0,a.jsx)("div",{value:"src/wasmJsMain",children:(0,a.jsxs)(n.p,{children:["Source code and resources that are needed for Web (WASM) target are stored in ",(0,a.jsx)(n.code,{children:"wasmJsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,a.jsx)("div",{value:"src/wasmJsMain/kotlin",children:(0,a.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,a.jsx)(n.code,{children:"main"})," function. The WASM version uses a platform-specific ",(0,a.jsx)(n.code,{children:"LocalStorePersistence"})," that is based on the browser's ",(0,a.jsx)(n.code,{children:"LocalStorage"}),". It also have a ",(0,a.jsx)(n.code,{children:"TrivialRouter"})," that uses ",(0,a.jsx)(n.code,{children:"window.location.hash"})," to track/update routes."]})}),(0,a.jsx)("div",{value:"src/wasmJsMain/resources",children:(0,a.jsxs)(n.p,{children:["Holds the ",(0,a.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (WASM) target."]})}),(0,a.jsx)("div",{value:"build.gradle.kts",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"build.gradle.kts"})," file defines how the app is configured and all its dependencies. The Contacts app uses a multi-platform configuration so it can run on all Doodle supported targets."]})})]})}),"\n",(0,a.jsxs)(n.p,{children:["Doodle apps are built using gradle like other Kotlin apps. The build is controlled by the ",(0,a.jsx)(n.code,{children:"build.gradle.kts"})," script in the root of the ",(0,a.jsx)(n.code,{children:"Contacts"})," directory."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"build.gradle.kts"})}),"\n",(0,a.jsx)(s.v,{children:c}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["The gradle build uses ",(0,a.jsx)(n.a,{href:"https://docs.gradle.org/current/userguide/version_catalogs.html",children:"gradle version catalogs"}),"; see ",(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file for library info."]})}),"\n",(0,a.jsx)(n.h2,{id:"the-application",children:"The Application"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactsApp.kt",children:(0,a.jsx)(n.code,{children:"ContactsApp"})})," is the entry point into our application. This is where the general structure of our app is defined. Note that Doodle creates all apps via constructor and passes their dependencies that way. This means the ContactsApp can begin work on setting up its views, layout, and routing directly in ",(0,a.jsx)(n.code,{children:"init"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Doodle apps can be ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. Use the ",(0,a.jsx)(n.code,{children:"application"})," function in a platform source-set (i.e. ",(0,a.jsx)(n.code,{children:"jsMain"}),", ",(0,a.jsx)(n.code,{children:"jvmMain"}),", etc.) to launch top-level apps. It takes a list of modules to load and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,a.jsx)(n.code,{children:"instance"}),", ",(0,a.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactsApp.kt#L19",children:(0,a.jsx)(n.strong,{children:"ContactsApp.kt"})})}),"\n",(0,a.jsx)(s.v,{children:d}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Notice that ",(0,a.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,a.jsx)(n.h3,{id:"async-assets",children:"Async Assets"}),"\n",(0,a.jsxs)(n.p,{children:["The app uses custom fonts and images, both of which require async loading via ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/text#fonts",children:(0,a.jsx)(n.code,{children:"FontLoader"})})," and ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/images",children:(0,a.jsx)(n.code,{children:"ImageLoader"})}),". It is easiest to load these within the app itself (instead of trying to load them in the launcher and injecting). We are using the ",(0,a.jsx)(n.code,{children:"AppConfig"})," interface to hold these assets and many different app attributes. The ",(0,a.jsx)(n.code,{children:"ContactsApp"})," therefore needs to create an instance of this config, which must happen asynchronously since it internally loads fonts and images. This is what the ",(0,a.jsx)(n.code,{children:"config"})," factory does, and why the app needs a ",(0,a.jsx)(n.code,{children:"CoroutineScope"})," and ",(0,a.jsx)(n.code,{children:"CoroutineDispatcher"})," injected."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactsApp.kt"})}),"\n",(0,a.jsx)(s.v,{children:"\nclass ContactsApp(\n  // ...\n  config      : suspend () -> AppConfig,\n  appScope    : CoroutineScope,\n  uiDispatcher: CoroutineDispatcher,\n  // ...\n): Application {\n  // ...\n  init {\n      appScope.launch(uiDispatcher) {\n          // ...\n\n          val appConfig = config() // load app configuration\n\n          // ...\n      }\n  }\n\n  // ...\n}\n"}),"\n",(0,a.jsxs)(n.p,{children:["Our launcher creates the ",(0,a.jsx)(n.code,{children:"appScope"})," ahead of app creation and injects it, along with ",(0,a.jsx)(n.code,{children:"Dispatchers.UI"})," (",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/browser/io.nacular.doodle.coroutines/-dispatchers",children:"web"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/desktop/io.nacular.doodle.coroutines/-dispatchers",children:"desktop"}),")."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"main.kt"})}),"\n",(0,a.jsx)(s.v,{children:"\nfun main() {\n  // ...\n  val appScope = CoroutineScope(SupervisorJob() + kotlinx.coroutines.Dispatchers.Default)\n\n  application (modules = listOf(\n      // ...\n  )) {\n      // load app\n      ContactsApp(\n          // ...\n          appScope     = appScope\n          uiDispatcher = Dispatchers.UI,\n          // ...\n      )\n  }\n}\n"}),"\n",(0,a.jsx)(n.h3,{id:"theming",children:"Theming"}),"\n",(0,a.jsxs)(n.p,{children:["Like most apps, we will use Views that rely on ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/behaviors",children:"Behaviors"})," to control their look and feel. This includes things like ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#textfield",children:"TextField"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#label",children:"Label"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/core/io.nacular.doodle.controls.panels/-scroll-panel",children:"ScrollPanel"}),", and ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls.buttons/-hyper-link",children:(0,a.jsx)(n.code,{children:"HyperLink"})}),". Therefore, we need to either provide these behaviors directly to each View, or use a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/themes",children:"Theme"})," that automatically binds behaviors to them. The latter approach is much simpler."]}),"\n",(0,a.jsxs)(n.p,{children:["In this case, we use the following behaviors by installing ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications#dependencies",children:"Modules"})," when initializing the app."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"main.kt"})}),"\n",(0,a.jsx)(s.v,{children:"\nfun main() {\n  // ...\n\n  application (modules = listOf(\n      // ...\n      basicLabelBehavior       (),\n      nativeTextFieldBehavior  (spellCheck = false),\n      nativeHyperLinkBehavior  (),\n      nativeScrollPanelBehavior(),\n      // ...\n  )) {\n      // load app\n      ContactsApp(\n          // ...\n          theme        = instance(), // automatically available b/c Behavior modules installed\n          themeManager = instance(), // automatically available b/c Behavior modules installed\n          // ...\n      )\n  }\n}\n"}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Notice that we also install modules to get support for ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/text#fonts",children:"fonts"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/images",children:"images"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/pointer_input/overview",children:"pointer"}),", ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/keyboard",children:"keyboard"})," and others."]})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Behavior"})," modules used can be consumed in our app via the ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/themes#dynamic-themes",children:"DynamicTheme"})," instance. This theme picks up all registered behaviors and installs them to the View type they are supposed to bind to. We can therefore inject this ",(0,a.jsx)(n.code,{children:"Theme"})," and a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/themes#thememanager",children:"ThemeManager"})," into the app's constructor."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactsApp.kt"})}),"\n",(0,a.jsx)(s.v,{children:"\nclass ContactsApp(\n  // ...\n  theme       : DynamicTheme,\n  themeManager: ThemeManager,\n  // ...\n): Application {\n  // ...\n  init {\n      appScope.launch(uiDispatcher) {\n          // ...\n          themeManager.selected = theme // Install theme\n          // ...\n      }\n  }\n\n  // ...\n}\n"}),"\n",(0,a.jsx)(n.h3,{id:"routing",children:"Routing"}),"\n",(0,a.jsxs)(n.p,{children:["This app relies on navigation and routes to display various screens. The Web (full screen) version supports deep linking as a result. The mapping between various routes and handlers is established in the ",(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactsApp.kt#L19",children:(0,a.jsx)(n.code,{children:"ContactsApp"})}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactsApp.kt"})}),"\n",(0,a.jsx)(s.v,{children:'\nclass ContactsApp(\n  // ...\n  router: Router,\n  // ...\n): Application {\n  // ...\n  init {\n      appScope.launch(uiDispatcher) {\n          // ...\n\n          // Register handlers for different routes\n          router[""                      ] = { _,_        -> /* Contact List     */ }\n          router["/add"                  ] = { _,_        -> /* Contact Creation */ }\n          router["/contact/([0-9]+)"     ] = { _, matches -> /* Contact          */ }\n          router["/contact/([0-9]+)/edit"] = { _, matches -> /* Contact Editing  */ }\n\n          // ...\n      }\n  }\n\n  // ...\n}\n'}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/Router.kt#L9",children:(0,a.jsx)(n.code,{children:"Router"})})," interface supports registration of handlers by regex strings. This allows for routes that contain variable data."]})}),"\n",(0,a.jsx)(n.h3,{id:"responsive-layout",children:"Responsive Layout"}),"\n",(0,a.jsxs)(n.p,{children:["The app has 3 top-level Views that are visible at all times. The ",(0,a.jsx)(n.a,{href:"#header",children:"Header"}),", main View, and Create Button. These are all placed within the ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/display",children:"Display"}),", and are positioned, sized according to the specified ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/positioning",children:"Layout"}),". That layout looks like this:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactsApp.kt"})}),"\n",(0,a.jsx)(s.v,{children:"\nclass ContactsApp(\n  // ...\n  display: Display,\n  // ...\n): Application {\n  // ...\n  init {\n      appScope.launch(uiDispatcher) {\n          // ...\n\n          display.layout = object: Layout {\n              // Header needs to be sized based on its minimumSize, so this layout should respond to any changes to it.\n              override fun requiresLayout(\n                  child: Positionable,\n                  of   : PositionableContainer,\n                  old  : View.SizePreferences,\n                  new  : View.SizePreferences\n              ) = new.minimumSize != old.minimumSize\n\n              override fun layout(container: PositionableContainer) {\n                  val mainView = container.children[1]\n                  val button   = container.children[2]\n\n                  header.size     = Size(container.width, header.minimumSize.height)\n                  mainView.bounds = Rectangle(INSET, header.height, max(0.0, header.width - 2 * INSET), max(0.0, container.height - header.height))\n\n                  button.bounds = when {\n                      container.width > header.filterCenterAboveWidth -> Rectangle(container.width - appAssets.createButtonLargeSize.width - 20, (header.naturalHeight - appAssets.createButtonLargeSize.height) / 2, appAssets.createButtonLargeSize.width, appAssets.createButtonLargeSize.height)\n                      else                                            -> Rectangle(container.width - appAssets.createButtonSmallSize.width - 20, container.height - appAssets.createButtonSmallSize.height - 40,      appAssets.createButtonSmallSize.width, appAssets.createButtonSmallSize.height)\n                  }\n              }\n          }\n\n          // ...\n      }\n  }\n\n  // ...\n}\n"}),"\n",(0,a.jsxs)(n.p,{children:["The Header is placed at the top and allowed to resize based on the ",(0,a.jsx)(n.code,{children:"Display"}),"'s width. The header will update its ",(0,a.jsx)(n.code,{children:"minimumSize"})," and ",(0,a.jsx)(n.code,{children:"idealSize"})," based on its width, which in turn will trigger a re-layout (see ",(0,a.jsx)(n.code,{children:"requiresLayout"})," above). The main View is always seated below the Header and takes the remaining space within the ",(0,a.jsx)(n.code,{children:"Display"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Notice that the Create Button is a floating View. It is aligned to the right of the Header when there is sufficient space, but pops down to the bottom-right when the app's width is below a threshold. The Header and other Views also adapt their internal layouts based on the app's width"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["The Create Button needs to be above all other Views, so the app ensures it is added to the ",(0,a.jsx)(n.code,{children:"Display"})," last."]})}),"\n",(0,a.jsx)(n.h2,{id:"main-views",children:"Main Views"}),"\n",(0,a.jsx)(n.h3,{id:"header",children:(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/Header.kt#L35",children:"Header"})}),"\n",(0,a.jsxs)(n.p,{children:["The app's header (which is always visible) provides a way to ",(0,a.jsx)(n.a,{href:"#filterbox",children:"filter"})," the ",(0,a.jsx)(n.a,{href:"#contact-list",children:"Contact List"})," and navigate back to it whenever the logo area is clicked. It also positions its contents in a way that allows the floating create button to sit along side them as though it is a child."]}),"\n",(0,a.jsx)(r.I,{function:"contactsHeader",height:"200"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Header.kt"})}),"\n",(0,a.jsx)(s.v,{children:'\nclass Header(/*...*/): View() {\n\n  /** Search box that filters which contacts are shown */\n  private inner class FilterBox: View() {\n      // ...\n  }\n\n          val naturalHeight          =  64.0\n  private val filterRightAboveWidth  = 672.0\n  private val filterCenterAboveWidth = 800.0\n  private val filterBox: FilterBox\n\n  val filterCentered: Boolean get() = width > filterCenterAboveWidth\n\n  var searchEnabled by observable(true) { _,new ->\n      filterBox.enabled = new\n  }\n\n  init {\n      children += Photo(assets.logo).apply { size = Size(40) }\n      children += Label("Phonebook").apply {\n          font            = assets.large\n          behavior        = CommonLabelBehavior(textMetrics)\n          acceptsThemes   = false\n          foregroundColor = assets.header\n      }\n      children += FilterBox().apply { size = Size(300, 45); font = assets.medium }.also { filterBox = it }\n\n      val filterNaturalWidth = 300.0\n\n      layout = Layout.simpleLayout { container ->\n          val logo   = container.children[0]\n          val label  = container.children[1]\n          val filter = container.children[2]\n\n          logo.position  = Point(2 * INSET, (naturalHeight - logo.height) / 2)\n          label.position = Point(logo.bounds.right + 10, logo.bounds.center.y - label.height / 2)\n\n          filter.bounds = when {\n              container.width > filterCenterAboveWidth -> Rectangle((container.width - filterNaturalWidth) / 2,        logo.bounds.center.y - filter.height / 2, filterNaturalWidth, filter.height)\n              container.width > filterRightAboveWidth  -> Rectangle( container.width - filterNaturalWidth - 2 * INSET, logo.bounds.center.y - filter.height / 2, filterNaturalWidth, filter.height)\n              else                                     -> Rectangle(logo.x, logo.bounds.bottom + INSET, max(0.0, container.width - 4 * INSET), filter.height)\n          }\n      }.then {\n          minimumSize = Size(width, max(0.0, filterBox.bounds.bottom + 8))\n          idealSize   = minimumSize\n      }\n\n      // Custom cursor when pointer in the "clickable" region\n      pointerMotionChanged += moved {\n          cursor = when {\n              it.inHotspot -> Pointer\n              else         -> null\n          }\n      }\n\n      // Show Contact list when "clickable" region clicked\n      pointerChanged += clicked {\n          if (it.inHotspot) {\n              navigator.showContactList()\n          }\n      }\n  }\n\n  private val PointerEvent.inHotspot get() = this@Header.toLocal(location, target).x < 220\n}\n'}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"The Header uses pointer tracking to update its Cursor and handle clicking within its hot spot."})}),"\n",(0,a.jsx)(n.h4,{id:"filterbox",children:"FilterBox"}),"\n",(0,a.jsxs)(n.p,{children:["The FilterBox is a simple wrapper around a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#textfield",children:"TextField"})," that adds some iconography, handles styling and manages the animations."]}),"\n",(0,a.jsx)(s.v,{children:'\nprivate inner class FilterBox: View() {\n\n  private var progress              by renderProperty(0f  )\n  private var animation: Animation? by observable    (null) { old,_ -> old?.cancel() }\n\n  private val searchIcon     = PathIcon<View>(path(assets.searchIcon), fill = assets.search, pathMetrics = pathMetrics)\n  private val searchIconSize = searchIcon.size(this)\n\n  val textField = TextField().apply {\n      placeHolder      = "Search"\n      borderVisible    = false\n      backgroundColor  = Transparent\n      placeHolderColor = assets.placeHolder\n      focusChanged    += { _,_,hasFocus ->\n          // animate progress based on focus state\n          animation = (animate (progress to if (hasFocus) 1f else 0f) using assets.slowTransition) {\n              progress = it\n          }\n      }\n  }\n\n  init {\n      cursor             = Text\n      clipCanvasToBounds = false\n\n      val clearButton = PathIconButton(pathData = assets.deleteIcon, pathMetrics = pathMetrics).apply {\n          size            = Size(22, 44)\n          cursor          = Pointer\n          visible         = textField.text.isNotBlank()\n          foregroundColor = assets.search\n          fired += {\n              textField.text = ""\n          }\n      }\n\n      textField.textChanged += { _,_,new ->\n          when {\n              new.isBlank() -> contacts.filter = null\n              else          -> contacts.filter = { it.name.contains(new, ignoreCase = true) }\n          }\n\n          clearButton.visible = new.isNotBlank()\n      }\n\n      children += textField\n      children += clearButton\n\n      layout = constrain(children[0], children[1]) { textField, clear ->\n          textField.left    = parent.left + searchIconSize.width + 2 * 20\n          textField.height  = parent.height\n          textField.right   = clear.left\n          textField.centerY = parent.centerY\n          clear.right       = parent.right - 20\n          clear.centerY     = parent.centerY\n      }\n\n      pointerChanged += clicked {\n          focusManager.requestFocus(textField)\n      }\n  }\n\n  override fun render(canvas: Canvas) {\n      when {\n          // draw shadow when animating (progress > 0)\n          progress > 0f -> canvas.outerShadow(horizontal = 0.0, vertical = 4.0 * progress, color = assets.shadow, blurRadius = 3.0 * progress) {\n              // interpolate color during animation\n              canvas.rect(bounds.atOrigin, radius = 8.0, color = interpolate(assets.searchSelected, assets.background, progress))\n          }\n          else          -> canvas.rect(bounds.atOrigin, radius = 8.0, color = assets.searchSelected)\n      }\n\n      searchIcon.render(this, canvas, at = Point(20.0, (height - searchIconSize.height) / 2))\n  }\n}\n'}),"\n",(0,a.jsx)(n.h3,{id:"contact-list",children:(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactList.kt#L35",children:"Contact List"})}),"\n",(0,a.jsxs)(n.p,{children:["This is the main view within the app. It displays the contacts in a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#table",children:"Table"})," with three columns: ",(0,a.jsx)(n.em,{children:"Name"}),", ",(0,a.jsx)(n.em,{children:"Phone Number"}),", and an untitled one to hold the edit/delete tool buttons. This View extends Doodle's ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#table",children:(0,a.jsx)(n.code,{children:"DynamicTable"})}),", which means it responds automatically to change in its underlying model. This is precisely what we need since Contacts will be added, edited, and deleted."]}),"\n",(0,a.jsx)(r.I,{function:"contactList",height:"550"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactList.kt"})}),"\n",(0,a.jsx)(s.v,{children:'\nclass ContactList(\n // ...\n): DynamicTable<Contact, MutableListModel<Contact>>(contacts, SingleItemSelectionModel(), block = {\n  val alignment      : Constraints.() -> Unit          = // ...\n  val nameVisualizer : CellVisualizer<Contact, String> = // ...\n  val toolsVisualizer: CellVisualizer<Contact, Unit>   = // ...\n\n  column(Label("Name"        ), { name        }, nameVisualizer   ) { cellAlignment = alignment; headerAlignment = alignment                }\n  column(Label("Phone Number"), { phoneNumber }, TextVisualizer() ) { cellAlignment = alignment; headerAlignment = alignment                }\n  column(null,                                   toolsVisualizer  ) { cellAlignment = fill(Insets(top = 20.0, bottom = 20.0, right = 20.0)) }\n}) {\n  init {\n      // ...\n\n      // Controls how the table\'s columns resize\n      columnSizePolicy = object: ColumnSizePolicy {\n          override fun layout(width: Double, columns: List<Column>, startIndex: Int): Double {\n              columns[2].width = if (width > 672.0 - 2 * INSET) 100.0 else 0.0 // FIXME: factor out hard-coded width\n              columns[0].width = width / 2\n              columns[1].width = width - columns[0].width - columns[2].width\n\n              return width\n          }\n\n          override fun widthChanged(width: Double, columns: List<Column>, index: Int, to: Double) {\n              // no-op\n          }\n      }\n\n      behavior      = ContactListBehavior(assets, navigator)\n      acceptsThemes = false\n  }\n}\n\n// ...\n'}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["ContactList uses a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls/-single-item-selection-model",children:(0,a.jsx)(n.code,{children:"SingleItemSelectionModel"})})," to ensure that only one row can be highlighted at a time."]})}),"\n",(0,a.jsxs)(n.p,{children:["The table's columns are defined (at construction time), and the sizing policy for their widths is specified in the ",(0,a.jsx)(n.code,{children:"apply"})," block. ",(0,a.jsx)(n.code,{children:"Table"}),"s are all strongly-typed, so this one can only store ",(0,a.jsx)(n.code,{children:"Contact"}),"s. Which means each column can derive its data from some component of a ",(0,a.jsx)(n.code,{children:"Contact"}),". The first two columns rely on ",(0,a.jsx)(n.code,{children:"Contact.name"})," and ",(0,a.jsx)(n.code,{children:"Contact.phoneNumber"})," respectively. But the last column takes no data in, since it will simply show buttons that fire events."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"columnSizePolicy"})," used sizes the columns so that they take up the entire table width and scale such that the 3rd one disappears when the table is below a threshold."]}),"\n",(0,a.jsx)(n.h4,{id:"custom-table-behavior",children:(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactListBehavior.kt#L29",children:"Custom Table Behavior"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ContactList"})," uses a custom ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/controls/io.nacular.doodle.controls.table/-table-behavior",children:(0,a.jsx)(n.code,{children:"TableBehavior"})})," via ",(0,a.jsx)(n.code,{children:"ContactListBehavior"}),". Doodle's ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#table",children:"Table"})," is very customizable, since it delegates a lot of functionality to ",(0,a.jsx)(n.code,{children:"TableBehavior"}),". We use this fact to specify how the header and body cells look and are positioned, as well as the way selection highlighting works."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactListBehavior.kt"})}),"\n",(0,a.jsx)(s.v,{children:'\nclass ContactListBehavior(private val assets: AppConfig, private val navigator: Navigator): TableBehavior<Contact>() {\n  private inner class ContactCell<T>(/*...*/): View() {\n      // Represents each cell in the table\'s body\n      // Navigates to ContactView on pointer press\n      // Adds/removes row selection (for highlighting) on pointer enter/exit\n  }\n\n  private val selectionChanged: SetObserver<Table<Contact, *>, Int> = { table,_,_ ->\n      // Repaint the Table to show selected rows\n      table.bodyDirty()\n  }\n\n  override fun install(view: Table<Contact, *>) {\n      view.selectionChanged += selectionChanged\n  }\n\n  override fun uninstall(view: Table<Contact, *>) {\n      view.selectionChanged -= selectionChanged\n  }\n\n  override val headerCellGenerator = object: AbstractTableBehavior.HeaderCellGenerator<Table<Contact, *>> {\n      override fun <A> invoke(table: Table<Contact, *>, column: Column<A>) = container {\n          // Column header cell with underline\n      }\n  }\n\n  override val headerPositioner = object: AbstractTableBehavior.HeaderPositioner<Table<Contact, *>> {\n      override fun invoke(table: Table<Contact, *>) = HeaderGeometry(0.0, TABLE_HEADER_HEIGHT)\n  }\n\n  // No overflow column will be in the Table\n  override val overflowColumnConfig: Nothing? = null\n\n  @Suppress("UNCHECKED_CAST")\n  override val cellGenerator: CellGenerator<Contact> = object: CellGenerator<Contact> {\n      override fun <A> invoke(table: Table<Contact, *>, column: Column<A>, cell: A, row: Int, itemGenerator: ItemVisualizer<A, IndexedItem>, current: View?): View = when (current) {\n          is ContactCell<*> -> (current as ContactCell<A>).apply { update(table, cell, row) }\n          else              -> ContactCell(table, column, cell, row, itemGenerator)\n      }\n  }\n\n  override val rowPositioner: RowPositioner<Contact> = object: RowPositioner<Contact> {\n      // Position rows like a vertical list\n      private val delegate = VerticalListPositioner(ROW_HEIGHT)\n\n      override fun rowBounds  (of: Table<Contact, *>, row: Contact, index: Int) = delegate.itemBounds (of.size,     of.insets, index)\n      override fun row        (of: Table<Contact, *>, at: Point               ) = delegate.itemFor    (of.size,     of.insets,  at  )\n      override fun minimumSize(of: Table<Contact, *>                          ) = delegate.minimumSize(of.numItems, of.insets       )\n  }\n\n  override fun renderBody(table: Table<Contact, *>, canvas: Canvas) {\n      canvas.rect(table.bounds.atOrigin, color = assets.background)\n\n      // Highlight selected rows\n      table.selection.map { it to table[it] }.forEach { (index, row) ->\n          row.onSuccess {\n              canvas.rect(rowPositioner.rowBounds(table, it, index).inset(Insets(top = 1.0)), assets.listHighlight)\n          }\n      }\n  }\n}\n'}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Highlighting on pointer hover is handled by each cell in the Table. ",(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/ContactListBehavior.kt#L29",children:(0,a.jsx)(n.code,{children:"ContactCell"})})," registers Pointer/MotionListeners and sets its row un/selected accordingly. This then results in ",(0,a.jsx)(n.code,{children:"ContactListBehavior"})," redrawing the Table background and coloring the selected rows."]})}),"\n",(0,a.jsx)(n.h3,{id:"contact-creation",children:(0,a.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Contacts/src/commonMain/kotlin/io/nacular/doodle/examples/contacts/CreateContactView.kt#L24",children:"Contact Creation"})}),"\n",(0,a.jsxs)(n.p,{children:["This View allows the user to create a new contact. It shows a preview of the avatar that will be used and takes text input for both the ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"phoneNumber"}),". This View uses child Views for these components, including a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/form",children:"Form"})," for the input fields."]}),"\n",(0,a.jsx)(r.I,{function:"contactCreation",height:"550"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CreateContactView.kt"})}),"\n",(0,a.jsx)(s.v,{children:'\nclass CreateContactView(\n  // ...\n): View() {\n  private inner class DynamicAvatar(private val image: Image): Avatar(textMetrics, "") {\n      override fun render(canvas: Canvas) {\n          when {\n              name.isBlank() -> canvas.clip(Circle(radius = min(width, height) / 2, center = Point(width / 2, height / 2))) {\n                  canvas.image(image, destination = bounds.atOrigin)\n              }\n              else -> super.render(canvas)\n          }\n      }\n  }\n\n  init {\n      lateinit var name       : String\n      lateinit var phoneNumber: String\n\n      val label = Label("Create Contact").apply {\n          font    = assets.medium\n          height  = 28.0\n          fitText = setOf(Width)\n      }\n\n      val back   = buttons.back  (assets.backIcon)\n      val avatar = DynamicAvatar (assets.blankAvatar).apply { size = Size(176); font = assets.medium }\n      val button = buttons.create(assets.buttonBackground, assets.buttonForeground).apply {\n          font     = assets.small\n          enabled  = false\n          fired   += {\n              contacts += Contact(name, phoneNumber)\n              navigator.showContactList()\n          }\n      }\n\n      val spacer = view {\n          height = 64.0\n          render = {\n              line(Point(0.0, height / 2), Point(width, height / 2), stroke = Stroke(assets.outline))\n          }\n      }\n\n      val form = editForm(\n          assets          = assets,\n          button          = button,\n          pathMetrics     = pathMetrics,\n          nameChanged     = { avatar.name = it },\n          textFieldStyler = textFieldStyler\n      ) { name_, phone_ ->\n          name           = name_\n          phoneNumber    = phone_\n          button.enabled = true\n      }\n\n      children += listOf(label, back, avatar, spacer, form, button)\n\n      layout = constrain(label, back, avatar, spacer, form, button) { (label, back, avatar, spacer, form, button) ->\n          // ...\n      }.then {\n          idealSize = Size(spacer.width + 2 * INSET, button.bounds.bottom + INSET)\n      }\n  }\n\n  // Helper to use constrain with 6 items\n  private operator fun <T> List<T>.component6() = this[5]\n}\n'}),"\n",(0,a.jsx)(n.h3,{id:"contact-view",children:"Contact View"}),"\n",(0,a.jsxs)(n.p,{children:["This View shows the details of a contact. It allows the user to edit or delete the contact. Editing jumps to the ",(0,a.jsx)(n.a,{href:"#contact-editing",children:"Contact Editing"})," screen."]}),"\n",(0,a.jsx)(r.I,{function:"contactView",height:"550"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ContactView.kt"})}),"\n",(0,a.jsx)(s.v,{children:'\nclass ContactView(/*...*/): ContactCommon(/*...*/) {\n  init {\n      edit.apply {\n          fired += {\n              // Show Contact edit when pressed\n              navigator.showContactEdit(super.contact)\n          }\n      }\n\n      val details = container {\n          this += Label("Contact Details").apply {\n              font    = assets.small\n              height  = 24.0\n              fitText = setOf(Width)\n          }\n          this += HyperLink(\n              url  = "tel:${contact.phoneNumber}",\n              text = contact.phoneNumber,\n              icon = PathIcon(path = path(assets.phoneIcon), pathMetrics = pathMetrics, fill = assets.phoneNumber),\n          ).apply {\n              font            = assets.small\n              acceptsThemes   = false\n              iconTextSpacing = INSET\n              behavior        = linkStyler(this, object: CommonTextButtonBehavior<HyperLink>(textMetrics) {\n                  override fun install(view: HyperLink) {\n                      super.install(view)\n                      val textSize = textMetrics.size(text, font)\n                      val iconSize = icon!!.size(view)\n\n                      // Ensure link\'s size includes icon and text\n                      size = Size(textPosition(view).x + textSize.width, max(iconSize.height, textSize.height))\n                  }\n\n                  override fun render(view: HyperLink, canvas: Canvas) {\n                      icon!!.render(view, canvas, at = iconPosition(view, icon = icon!!))\n\n                      // Styled text with phoneNumberLink color and link\'s font\n                      canvas.text(assets.phoneNumberLink.invoke { view.font(view.text) }, at = textPosition(view))\n                  }\n              }) as Behavior<Button>\n          }\n\n          render = {\n              rect(bounds.atOrigin.inset(0.5), radius = 12.0, stroke = Stroke(assets.outline))\n          }\n\n          layout = constrain(children[0], children[1]) { label, link ->\n              label.top  = parent.top   + INSET\n              label.left = parent.left  + INSET\n              link.top   = label.bottom + INSET\n              link.left  = label.left\n          }\n      }\n\n      setDetail(details)\n\n      layout = simpleLayout { layoutCommonItems() }.then {\n          idealSize = Size(spacer.width + 2 * INSET, details.bounds.bottom + INSET)\n      }\n  }\n}\n'}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["This view uses a customized HyperLink that contains an icon. HyperLinks are Buttons whose behaviors can be modified. In this case, we want the link to behave like a normal link, but fully customize the rendering. This is why we need to use ",(0,a.jsx)(n.code,{children:"linkStyler"}),", which is a ",(0,a.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/themes/io.nacular.doodle.theme.native/-native-hyper-link-styler",children:(0,a.jsx)(n.code,{children:"NativeHyperLinkStyler"})}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"contact-editing",children:"Contact Editing"}),"\n",(0,a.jsxs)(n.p,{children:["Contacts are edited using this View. It is fairly similar to the CreateContactView, in that it displays the contact's avatar, ",(0,a.jsx)(n.code,{children:"name"}),", ",(0,a.jsx)(n.code,{children:"phoneNumber"}),", and presents a form to modify them. It also has a delete button to remove the Contact. This View shares a lot of structure with ",(0,a.jsx)(n.code,{children:"ContactView"})," that is placed in the ",(0,a.jsx)(n.code,{children:"ContactCommon"})," base class."]}),"\n",(0,a.jsx)(r.I,{function:"contactEditing",height:"620"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"EditContactView.kt"})}),"\n",(0,a.jsx)(s.v,{children:"\nclass EditContactView(\n  // ...\n): ContactCommon(\n  // ...\n) {\n  init {\n      lateinit var newName       : String\n      lateinit var newPhoneNumber: String\n\n      edit.apply {\n          enabled = false\n          fired += {\n              // tries to edit its contact\n              contacts.edit(super.contact) {\n                  name        = newName\n                  phoneNumber = newPhoneNumber\n              }.onSuccess {\n                  super.contact = it // updates its contact to the newly edited one\n              }\n\n              enabled = false\n          }\n      }\n\n      val form = editForm(super.contact.name, super.contact.phoneNumber, assets, textFieldStyler, pathMetrics, edit) { name, phone ->\n          // called whenever the Form becomes valid\n          newName        = name\n          newPhoneNumber = phone\n          edit.enabled   = name != super.contact.name || phone != super.contact.phoneNumber\n      }\n\n      setDetail(form) // super class utility for specifying details view\n\n      layout = simpleLayout {\n          layoutCommonItems() // super class utility\n\n          edit.position = Point(form.x, form.bounds.bottom + 2 * INSET)\n      }.then {\n          idealSize = Size(spacer.width + 2 * INSET, edit.bounds.bottom + INSET)\n      }\n  }\n}\n"})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(g,{...e})}):g(e)}}}]);