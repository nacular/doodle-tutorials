"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7881],{4307:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>g,frontMatter:()=>h,metadata:()=>t,sourceTree:()=>m,toc:()=>f});const t=JSON.parse('{"id":"todo","title":"Todo","description":"Todo Tutorial","source":"@site/docs/todo.mdx","sourceDirName":".","slug":"/todo","permalink":"/doodle-tutorials/docs/todo","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Todo","hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"Calculator","permalink":"/doodle-tutorials/docs/calculator"},"next":{"title":"Photos","permalink":"/doodle-tutorials/docs/photos"}}');var i=o(4848),r=o(8453),a=(o(4865),o(9365),o(854)),l=o(9053),s=o(7020);const d='@file:OptIn(ExperimentalWasmDsl::class)\n\nimport org.jetbrains.kotlin.gradle.targets.js.dsl.ExperimentalWasmDsl\n\n//sampleStart\nplugins {\n    kotlin("multiplatform"          )\n    alias(libs.plugins.serialization)\n    application\n}\n\nkotlin {\n    js     { browser { binaries.executable() } } // Web     (JS  ) executable\n    wasmJs { browser { binaries.executable()     // Web     (WASM) executable\n        applyBinaryen {}                         // Binary size optimization\n    } }\n    jvm    {                                     // Desktop (JVM ) executable\n        compilations.all {\n            kotlinOptions { jvmTarget = "11" }   // JVM 11 is needed for Desktop\n        }\n        withJava()\n    }\n\n    sourceSets {\n        commonMain.dependencies {\n            api(libs.coroutines.core   ) // font loading\n            api(libs.serialization.json) // persistence\n\n            api(libs.doodle.themes     )\n            api(libs.doodle.controls   )\n        }\n\n        // Web (JS) platform source set\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        // Web (WASM) platform source set\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.doodle.browser)\n            }\n        }\n\n        // Desktop (JVM) platform source set\n        jvmMain.dependencies {\n            // helper to derive OS/architecture pair\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n    }\n}\n\n// Desktop entry point\napplication {\n    mainClass.set("io.nacular.doodle.examples.MainKt")\n}\n//sampleEnd\n\n// could be moved to buildSrc, but kept here for clarity\nfun osTarget(): String {\n    val osName = System.getProperty("os.name")\n    val targetOs = when {\n        osName == "Mac OS X"       -> "macos"\n        osName.startsWith("Win"  ) -> "windows"\n        osName.startsWith("Linux") -> "linux"\n        else                       -> error("Unsupported OS: $osName")\n    }\n\n    val targetArch = when (val osArch = System.getProperty("os.arch")) {\n        "x86_64", "amd64" -> "x64"\n        "aarch64"         -> "arm64"\n        else              -> error("Unsupported arch: $osArch")\n    }\n\n    return "${targetOs}-${targetArch}"\n}',c='package io.nacular.doodle.examples\n\nimport io.nacular.doodle.application.Application\nimport io.nacular.doodle.controls.IndexedItem\nimport io.nacular.doodle.controls.buttons.Button\nimport io.nacular.doodle.controls.buttons.HyperLink\nimport io.nacular.doodle.controls.itemVisualizer\nimport io.nacular.doodle.controls.list.MutableList\nimport io.nacular.doodle.controls.list.listEditor\nimport io.nacular.doodle.controls.panels.ScrollPanel\nimport io.nacular.doodle.controls.text.Label\nimport io.nacular.doodle.controls.theme.CommonLabelBehavior\nimport io.nacular.doodle.core.Behavior\nimport io.nacular.doodle.core.Container\nimport io.nacular.doodle.core.Display\nimport io.nacular.doodle.core.View\nimport io.nacular.doodle.core.container\nimport io.nacular.doodle.drawing.Canvas\nimport io.nacular.doodle.drawing.Color\nimport io.nacular.doodle.drawing.Color.Companion.Black\nimport io.nacular.doodle.drawing.Color.Companion.Transparent\nimport io.nacular.doodle.drawing.Color.Companion.White\nimport io.nacular.doodle.drawing.Font\nimport io.nacular.doodle.drawing.Font.Style.Italic\nimport io.nacular.doodle.drawing.FontLoader\nimport io.nacular.doodle.drawing.PatternPaint\nimport io.nacular.doodle.drawing.Stroke\nimport io.nacular.doodle.drawing.TextMetrics\nimport io.nacular.doodle.drawing.height\nimport io.nacular.doodle.drawing.opacity\nimport io.nacular.doodle.drawing.paint\nimport io.nacular.doodle.drawing.rect\nimport io.nacular.doodle.event.PointerListener.Companion.released\nimport io.nacular.doodle.examples.DataStore.DataStoreListModel\nimport io.nacular.doodle.examples.DataStore.Filter\nimport io.nacular.doodle.examples.DataStore.Filter.Active\nimport io.nacular.doodle.examples.DataStore.Filter.Completed\nimport io.nacular.doodle.focus.FocusManager\nimport io.nacular.doodle.geometry.Point\nimport io.nacular.doodle.geometry.Rectangle\nimport io.nacular.doodle.geometry.Size\nimport io.nacular.doodle.image.Image\nimport io.nacular.doodle.image.ImageLoader\nimport io.nacular.doodle.layout.Insets\nimport io.nacular.doodle.layout.constraints.Strength.Companion.Strong\nimport io.nacular.doodle.layout.constraints.constrain\nimport io.nacular.doodle.layout.constraints.fill\nimport io.nacular.doodle.theme.ThemeManager\nimport io.nacular.doodle.theme.adhoc.DynamicTheme\nimport io.nacular.doodle.theme.basic.list.BasicListBehavior\nimport io.nacular.doodle.theme.basic.list.BasicVerticalListPositioner\nimport io.nacular.doodle.theme.basic.list.TextEditOperation\nimport io.nacular.doodle.theme.basic.list.basicItemGenerator\nimport io.nacular.doodle.theme.native.NativeHyperLinkStyler\nimport io.nacular.doodle.utils.Dimension.Height\nimport io.nacular.doodle.utils.Encoder\nimport io.nacular.doodle.utils.diff.Delete\nimport io.nacular.doodle.utils.diff.Insert\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport kotlin.Result.Companion.success\nimport kotlin.math.min\n\n/**\n * This app is designed to run both top-level and nested. The filter buttons use hyperlinks in the spec,\n * but we will delegate their definition to the app creator to allow a different approach when nested\n * (i.e. using buttons instead of hyperlinks).\n *\n * The app will then use this provider to create the filter buttons.\n */\ninterface FilterButtonProvider {\n    operator fun invoke(text: String, filter: Filter? = null, behavior: Behavior<Button>): Button\n}\n\n/**\n * Default implementation intended for use when app is top-level. It handles routing and provides\n * hyperlinks for the filter buttons.\n */\nclass LinkFilterButtonProvider(private val dataStore: DataStore, router: Router, private val linkStyler: NativeHyperLinkStyler): FilterButtonProvider {\n    init {\n        router["/"         ] = { dataStore.filter = null      }\n        router["/active"   ] = { dataStore.filter = Active    }\n        router["/completed"] = { dataStore.filter = Completed }\n        router.fireAction()\n    }\n\n    override fun invoke(text: String, filter: Filter?, behavior: Behavior<Button>): Button {\n        val url = when (filter) {\n            Active    -> "#/active"\n            Completed -> "#/completed"\n            else      -> "#/"\n        }\n\n        return HyperLink(url = url, text = text).apply {\n            this.behavior            = linkStyler(this, behavior) as Behavior<Button>\n            this.acceptsThemes       = false\n            dataStore.filterChanged += { rerender() }\n        }\n    }\n}\n\n/**\n * General styling config\n */\ndata class TodoConfig(\n    val listFont              : Font,\n    val titleFont             : Font,\n    val lineColor             : Color  = Color(0xEDEDEDu),\n    val filterFont            : Font,\n    val footerFont            : Font,\n    val headerColor           : Color  = Color(0xAF2F2Fu) opacity 0.15f,\n    val deleteColor           : Color  = Color(0xCC9A9Au),\n    val appBackground         : Color  = Color(0xF5F5F5u),\n    val boldFooterFont        : Font,\n    val selectAllColor        : Color  = Color(0x737373u),\n    val checkForeground       : Image,\n    val checkBackground       : Image,\n    val placeHolderFont       : Font,\n    val placeHolderText       : String = "What needs to be done?",\n    val placeHolderColor      : Color  = Color(0xE6E6E6u),\n    val labelForeground       : Color  = Color(0x4D4D4Du),\n    val footerForeground      : Color  = Color(0xBFBFBFu),\n    val deleteHoverColor      : Color  = Color(0xAF5B5Eu),\n    val taskCompletedColor    : Color  = Color(0xD9D9D9u),\n    val clearCompletedText    : String = "Clear completed",\n    val textFieldBackground   : Color  = White,\n    val filterButtonForeground: Color  = Color(0x777777u),\n)\n\n/**\n * A [TextEditOperation] that translates a String to a [Task]. It also customizes the textField to fit the app\'s styling\n */\nprivate class TaskEditOperation(focusManager: FocusManager?, list: MutableList<Task, *>, task: Task, current: View): TextEditOperation<Task>(focusManager, TaskEncoder(task.completed), list, task, current) {\n    private class TaskEncoder(private val completed: Boolean = false): Encoder<Task, String> {\n        override fun decode(b: String) = success(Task(b, completed))\n        override fun encode(a: Task  ) = success(a.text)\n    }\n\n    init {\n        textField.fitText         = emptySet()\n        textField.backgroundColor = Transparent\n    }\n\n    override fun invoke() = container {\n        children += textField\n        layout    = constrain(textField) { it.edges eq parent.edges + Insets(top = 1.0, left = 58.0, bottom = 1.0) }\n    }\n}\n\n/**\n * This is the main view of the app. It contains all the visual elements.\n *\n * @property config that provides styling and resources (i.e. font, images)\n * @property dataStore that tracks the overall state of tasks\n * @property linkStyler used to wrap our custom Hyperlink Behavior in a native one so we get the default link behavior as well\n * @property textMetrics used to measure text\n * @property focusManager used to control focus in the app\n * @property filterButtonProvider used to create the filter buttons\n */\nprivate class TodoView(\n    private val config              : TodoConfig,\n    private val dataStore           : DataStore,\n    private val linkStyler          : NativeHyperLinkStyler,\n    private val textMetrics         : TextMetrics,\n    private val focusManager        : FocusManager,\n    private val filterButtonProvider: FilterButtonProvider\n): View() {\n\n    init {\n        val header = Label("todos").apply {\n            font            = config.titleFont\n            behavior        = CommonLabelBehavior(textMetrics)\n            acceptsThemes   = false\n            foregroundColor = config.headerColor\n        }\n        lateinit var list: View\n        val footer   = Footer(textMetrics, linkStyler, config)\n        val taskList = object: Container() {\n            init {\n                clipCanvasToBounds = false\n\n                // Maps tasks to TaskRow and updates them when recycled\n                val visualizer = itemVisualizer<Task, IndexedItem> { item, previous, _ ->\n                    when (previous) {\n                        is TaskRow -> previous.also { it.task = item }\n                        else       -> TaskRow(config, dataStore, item)\n                    }\n                }\n\n                // List containing Tasks. It is mutable since items can be edited\n                list = MutableList(DataStoreListModel(dataStore), itemVisualizer = visualizer, fitContent = setOf(Height)).apply {\n                    val rowHeight = 58.0\n                    font          = config.listFont\n                    cellAlignment = fill\n                    editor        = listEditor { list, row, _, current -> TaskEditOperation(focusManager, list, row, current) }\n                    behavior      = BasicListBehavior(focusManager,\n                        basicItemGenerator {\n                            // edit when double-clicked\n                            pointerChanged += released { event ->\n                                if (event.clickCount >= 2) { this@apply.startEditing(index).also { event.consume() } }\n                            }\n                        },\n                        BasicVerticalListPositioner(rowHeight),\n                        PatternPaint(Size(10.0, rowHeight)) {\n                            rect(Rectangle(size = this.size), color = White)\n                            line(Point(y = 1), Point(10, 1), Stroke(config.lineColor))\n                        },\n                    )\n\n                    itemsChanged += { _, differences ->\n                        // Scroll when a single item added\n                        var numAdded    = 0\n                        var numRemoved  = 0\n                        var indexInList = 0\n\n                        differences.forEach {\n                            when (it) {\n                                is Insert -> {\n                                    if (it.items.size > 1) {\n                                        return@forEach\n                                    }\n\n                                    ++numAdded\n                                    ++indexInList\n                                }\n                                is Delete -> {\n                                    numRemoved += it.items.size\n                                }\n                                else      -> indexInList += it.items.size\n                            }\n                        }\n\n                        if (numAdded == 1 && numRemoved <= 1) {\n                            scrollTo(indexInList)\n                        }\n                    }\n\n                    boundsChanged += { _, old, new ->\n                        if (old.width != new.width || old.height != new.height) {\n                            this@TodoView.relayout()\n                        }\n                    }\n                }\n\n                children += listOf(\n                    TaskCreationBox(focusManager, textMetrics, config, dataStore),\n                    ScrollPanel    (list).apply { contentWidthConstraints = { it eq width - verticalScrollBarWidth } },\n                    FilterBox      (config, dataStore, textMetrics, filterButtonProvider)\n                )\n\n                layout = constrain(children[0], children[1], children[2]) { input, panel, filter ->\n                    listOf(input, panel, filter).forEach { it.width eq parent.width }\n                    input.top     eq 0\n                    input.height.preserve\n                    panel.top     eq input.bottom\n\n                    if (children[2].visible) {\n                        filter.top    eq panel.bottom\n                        filter.bottom eq parent.bottom\n                        filter.height.preserve\n                    }\n                }\n            }\n\n            override fun render(canvas: Canvas) {\n                canvas.outerShadow(vertical =  2.0, blurRadius =  4.0, color = Black opacity 0.2f) {\n                    outerShadow   (vertical = 25.0, blurRadius = 50.0, color = Black opacity 0.1f) {\n                        // Create stacked effect\n                        if (!dataStore.isEmpty) {\n                            rect(bounds.atOrigin.inset(Insets(top = height, left = 8.0, right = 8.0, bottom = -8.0)), color = White)\n                            rect(bounds.atOrigin.inset(Insets(top = height, left = 4.0, right = 4.0, bottom = -4.0)), color = White)\n                        }\n                        rect(bounds.atOrigin, color = White)\n                    }\n                }\n            }\n        }\n\n        children += listOf(header, taskList, footer)\n\n        list.boundsChanged += { _,_,_ -> doLayout() }\n\n        layout = constrain(header, taskList, footer) { header, body, footer ->\n            listOf(header, body, footer).forEach { it.centerX eq parent.centerX }\n            header.top    eq        9\n            header.height.preserve\n\n            val minHeight = taskList.children[0].height + (taskList.children[2].takeIf { it.visible }?.height ?: 0.0)\n\n            body.top    eq header.bottom + 5\n            body.width  eq min(550.0, parent.width - 10)\n            body.height eq minHeight + list.height\n\n            footer.top   eq body.bottom + 65\n            footer.width eq body.width\n            footer.height.preserve\n            (footer.bottom lessEq parent.bottom) .. Strong\n        }\n    }\n}\n\n/**\n * Todo App based on TodoMVC\n */\nclass TodoApp(display             : Display,\n              uiDispatcher        : CoroutineDispatcher,\n              fonts               : FontLoader,\n              theme               : DynamicTheme,\n              themes              : ThemeManager,\n  private val images              : ImageLoader,\n              dataStore           : DataStore,\n              linkStyler          : NativeHyperLinkStyler,\n              textMetrics         : TextMetrics,\n              focusManager        : FocusManager,\n              filterButtonProvider: FilterButtonProvider): Application {\n//sampleStart\n    init {\n        val appScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n\n        // Launch coroutine to fetch fonts/images\n        appScope.launch(uiDispatcher) {\n            val titleFont  = fonts            { size = 100; weight = 100; families = listOf("Helvetica Neue", "Helvetica", "Arial", "sans-serif") }!!\n            val listFont   = fonts(titleFont) { size =  24 }!!\n            val footerFont = fonts(titleFont) { size =  10 }!!\n            val config     = TodoConfig(\n                listFont        = listFont,\n                titleFont       = titleFont,\n                footerFont      = footerFont,\n                filterFont      = fonts(titleFont ) { size   = 14     }!!,\n                boldFooterFont  = fonts(footerFont) { weight = 400    }!!,\n                placeHolderFont = fonts(listFont  ) { style  = Italic }!!,\n                checkForeground = checkForegroundImage(),\n                checkBackground = checkBackgroundImage(),\n            )\n\n            // install theme\n            themes.selected = theme\n\n            display += TodoView(config, dataStore, linkStyler, textMetrics, focusManager, filterButtonProvider)\n\n            display.layout = constrain(display.children[0]) { it.edges eq parent.edges }\n\n            display.fill(config.appBackground.paint)\n        }\n    }\n//sampleEnd\n\n    override fun shutdown() {}\n\n    private suspend fun checkForegroundImage() = images.load("data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E")!!\n    private suspend fun checkBackgroundImage() = images.load("data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E")!!\n}',h={title:"Todo",hide_title:!0},p=void 0,u={},m=(0,s.a)([{label:"src",children:[{label:"commonMain",children:[{label:"kotlin"}]},{label:"jsMain",children:[{label:"kotlin"},{label:"resources"}]},{label:"jvmMain",children:[{label:"kotlin"}]},{label:"wasmJsMain",children:[{label:"kotlin"},{label:"resources"}]}]},{label:"build.gradle.kts"}]),f=[{value:"Project Setup",id:"project-setup",level:2},{value:"The Application",id:"the-application",level:2},{value:"Supporting Docs Embedding",id:"supporting-docs-embedding",level:2}];function v(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("h1",{children:(0,i.jsx)("a",{class:"inline-github-link",href:"https://github.com/nacular/doodle-tutorials/tree/master/Todo",target:"_blank",children:"Todo Tutorial"})}),"\n",(0,i.jsxs)(n.p,{children:["This tutorial shows how you might build the ",(0,i.jsx)(n.a,{href:"http://todomvc.com",children:"TodoMVC"})," app using Doodle. This version deviates from the official app spec in that (like all Doodle apps) it does not use CSS or HTML directly. Therefore, it does not include the assets provided by the official spec. Instead, it replicates the UX with Doodle primitives."]}),"\n",(0,i.jsx)(n.p,{children:"This version is also designed to work well as an embedded app. The version below (unlike the full-screen version) does not use routing for the filters. This means there is no way to deep-link to a filter, like the full-screen version has. The launch code decides this by injecting a different strategy for creating the filter buttons, while the app itself is unaware of this difference."}),"\n",(0,i.jsx)(l.I,{function:"todo",height:"700"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can also see the full-screen app here: ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/todo",children:"JavaScript"}),", ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/todo_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,i.jsx)(n.p,{children:"The app will use a Kotlin Multiplatform setup, which means we can run it on a range of targets supported by Doodle. The directory structure follows a fairly common layout, with common classes and resources in one source set and platform-specific items in their own."}),"\n","\n",(0,i.jsx)(n.admonition,{title:"Directory Layout",type:"info",children:(0,i.jsxs)(s.k,{items:m,defaultExpandedItems:["src","src/commonMain"],defaultSelectedItem:"src",children:[(0,i.jsxs)("div",{value:"src",children:[(0,i.jsxs)(n.p,{children:["All source code and resources are located under the ",(0,i.jsx)(n.code,{children:"src"})," directory."]}),(0,i.jsxs)(n.p,{children:["The application logic itself is located in the common source set (",(0,i.jsx)(n.code,{children:"src/commonMain"}),"), which means it is entirely reused for each platform. In fact, the same app is used unchanged (just targeting JS) within this documentation."]})]}),(0,i.jsxs)("div",{value:"src/commonMain",children:[(0,i.jsxs)(n.p,{children:["Source code and resources for that are usable for platforms are stored in ",(0,i.jsx)(n.code,{children:"commonMain"}),". This app is designed to work on all platforms, so our app code and all logic is found under this directory."]}),(0,i.jsxs)(n.p,{children:["There are also a couple interfaces that need platform-specific implementations that are defined here: ",(0,i.jsx)(n.code,{children:"PersistentStore"})," and ",(0,i.jsx)(n.code,{children:"Router"}),". This allows our app to work with them in a platform independent way, even if they will vary depending on the target it is run on."]})]}),(0,i.jsxs)("div",{value:"src/commonMain/kotlin",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"kotlin"})," directory is where all code for a platform resides. In this case, we have all the classes for our app, including ",(0,i.jsx)(n.code,{children:"TodoApp"}),", ",(0,i.jsx)(n.code,{children:"TaskRow"}),", ",(0,i.jsx)(n.code,{children:"FilterBox"}),", ",(0,i.jsx)(n.code,{children:"Router"}),", etc.."]}),(0,i.jsx)(n.p,{children:"All of these classes are platform agnostic and used by all targets. This makes our app work on any target Doodle supports."})]}),(0,i.jsx)("div",{value:"src/jsMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Web (JS) target are stored in ",(0,i.jsx)(n.code,{children:"jsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,i.jsx)("div",{value:"src/jsMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function. The JS version uses a platform-specific ",(0,i.jsx)(n.code,{children:"LocalStorePersistence"})," that is based on the browser's ",(0,i.jsx)(n.code,{children:"LocalStorage"}),". It also have a ",(0,i.jsx)(n.code,{children:"TrivialRouter"})," that uses ",(0,i.jsx)(n.code,{children:"window.location.hash"})," to track/update routes."]})}),(0,i.jsx)("div",{value:"src/jsMain/resources",children:(0,i.jsxs)(n.p,{children:["Holds the ",(0,i.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (JS) target."]})}),(0,i.jsx)("div",{value:"src/jvmMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Desktop (JVM) target are stored in ",(0,i.jsx)(n.code,{children:"jvmMain"}),"."]})}),(0,i.jsx)("div",{value:"src/jvmMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Desktop launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function. This version uses a platform-specific ",(0,i.jsx)(n.code,{children:"FilePersistence"})," that is based on the file system via ",(0,i.jsx)(n.code,{children:"java.io.File"}),". It also has an ",(0,i.jsx)(n.code,{children:"InMemoryRouter"})," that uses a hashmap internally to track/update routes."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain",children:(0,i.jsxs)(n.p,{children:["Source code and resources that are needed for Web (WASM) target are stored in ",(0,i.jsx)(n.code,{children:"wasmJsMain"}),". Our app is platform agnostic except for the launch portion, which is located in the source below this directory."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain/kotlin",children:(0,i.jsxs)(n.p,{children:["The Web launch portion of our app is located here in the program's ",(0,i.jsx)(n.code,{children:"main"})," function. The WASM version uses a platform-specific ",(0,i.jsx)(n.code,{children:"LocalStorePersistence"})," that is based on the browser's ",(0,i.jsx)(n.code,{children:"LocalStorage"}),". It also have a ",(0,i.jsx)(n.code,{children:"TrivialRouter"})," that uses ",(0,i.jsx)(n.code,{children:"window.location.hash"})," to track/update routes."]})}),(0,i.jsx)("div",{value:"src/wasmJsMain/resources",children:(0,i.jsxs)(n.p,{children:["Holds the ",(0,i.jsx)(n.code,{children:"index.html"})," file that loads the generated JS file produced for the Web (WASM) target."]})}),(0,i.jsx)("div",{value:"build.gradle.kts",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"build.gradle.kts"})," file defines how the app is configured and all its dependencies. The Todo app uses a multi-platform configuration so it can run on all Doodle supported targets."]})})]})}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps are built using gradle like other Kotlin apps. The build is controlled by the ",(0,i.jsx)(n.code,{children:"build.gradle.kts"})," script in the root of the ",(0,i.jsx)(n.code,{children:"Todo"})," directory."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"build.gradle.kts"})}),"\n",(0,i.jsx)(a.v,{children:d}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The gradle build uses ",(0,i.jsx)(n.a,{href:"https://docs.gradle.org/current/userguide/version_catalogs.html",children:"gradle version catalogs"}),"; see ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file for library info."]})}),"\n",(0,i.jsx)(n.h2,{id:"the-application",children:"The Application"}),"\n",(0,i.jsxs)(n.p,{children:["All Doodle apps must implement the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:(0,i.jsx)(n.code,{children:"Application"})})," interface. The framework will then initialize our app via the constructor."]}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps can be defined in ",(0,i.jsx)(n.code,{children:"commonMain"}),", since they do not require any platform-specific dependencies (we will do this as well). They can also be ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. Use the ",(0,i.jsx)(n.code,{children:"application"})," function in a platform source-set (i.e. ",(0,i.jsx)(n.code,{children:"jsMain"}),", ",(0,i.jsx)(n.code,{children:"jvmMain"}),", etc.) to launch top-level apps. It takes a list of modules to load and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,i.jsx)(n.code,{children:"instance"}),", ",(0,i.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Todo/src/commonMain/kotlin/io/nacular/doodle/examples/TodoApp.kt#L11",children:(0,i.jsx)(n.strong,{children:"TodoApp.kt"})})}),"\n",(0,i.jsx)(a.v,{children:c}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"application"})," function to launch top-level apps. It takes a list of modules, and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,i.jsx)(n.code,{children:"instance"}),", ",(0,i.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we have included several modules for our app. This includes one for fonts, pointer, keyboard, and several for various View ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/behaviors",children:(0,i.jsx)(n.code,{children:"Behaviors"})})," (i.e. ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-api/browser/io.nacular.doodle.theme.native/-native-theme/-companion/native-text-field-behavior.html",children:(0,i.jsx)(n.code,{children:"nativeTextFieldBehavior()"})}),") which loads the native behavior for TextFields. We also define some bindings directly in a new module. These are items with no built-in module, or items that only exist in our app code."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Check out Kodein to learn more about how it handles dependency injection."})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"application"})," function also takes an optional HTML element within which the app will be hosted. The app will be hosted in ",(0,i.jsx)(n.code,{children:"document.body"})," if you do not specify an element."]}),"\n",(0,i.jsx)(n.p,{children:"App launching is the only part of our code that is platform-specific; since it is the only time we might care about an HTML element. It also helps support embedding apps into non-Doodle contexts."}),"\n",(0,i.jsx)(n.h2,{id:"supporting-docs-embedding",children:"Supporting Docs Embedding"}),"\n",(0,i.jsxs)(n.p,{children:["These docs actually launch the app using a custom ",(0,i.jsx)(n.code,{children:"main"})," with a slightly different set of inputs. The big difference is in ",(0,i.jsx)(n.code,{children:"FilterButtonProvider"})," used. The docs inject a provider that creates ",(0,i.jsx)(n.code,{children:"PushButton"}),"s instead of ",(0,i.jsx)(n.code,{children:"HyperLink"}),"s for the filter controls. The app itself treats these the same. The end result is that the docs version does not use routing."]}),"\n",(0,i.jsx)(a.v,{children:'\n// Notice the element is provided for embedded version\napplication(root = element, modules = listOf(FontModule, PointerModule, KeyboardModule, basicLabelBehavior(),\n      nativeTextFieldBehavior(), nativeHyperLinkBehavior(), nativeScrollPanelBehavior(smoothScrolling = true),\n      Module(name = "AppModule") {\n          // ...\n\n          // Different behavior for docs version\n          bind<FilterButtonProvider>() with singleton { EmbeddedFilterButtonProvider(instance()) }\n      }\n)) {\n  // load app just like full-screen\n  TodoApp(instance(), instance(), instance(), instance(), instance(), instance(), instance(), instance(), instance(), instance())\n}\n'})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}}}]);