"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[763],{5507:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>u,default:()=>b,frontMatter:()=>h,metadata:()=>p,toc:()=>x});var i=t(4848),o=t(8453),a=t(1470),l=t(9365);t(1432);const s='plugins {\n    kotlin("multiplatform")\n}\n\nkotlin {\n    // Defined in buildSrc/src/main/kotlin/Common.kt\n    jsTargets    ()\n    jvmTargets   ()\n    wasmJsTargets()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                api(libs.coroutines.core)\n                api(libs.doodle.controls)\n            }\n        }\n\n        jvmTest {\n            dependencies {\n                implementation(kotlin("test-junit"))\n                implementation(libs.bundles.test.libs)\n            }\n        }\n    }\n}',r='plugins {\n    kotlin("multiplatform")\n    application\n}\n\nkotlin {\n    jsTargets    (executable = true)\n    wasmJsTargets(executable = true)\n    jvmTargets   (                 )\n\n    sourceSets {\n        commonMain.dependencies {\n            implementation(project(":Calculator"))\n        }\n\n        jsMain.dependencies {\n            implementation(libs.doodle.browser)\n        }\n\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(libs.doodle.browser)\n            }\n        }\n\n        jvmMain.dependencies {\n            when (osTarget()) {\n                "macos-x64"     -> implementation(libs.doodle.desktop.jvm.macos.x64    )\n                "macos-arm64"   -> implementation(libs.doodle.desktop.jvm.macos.arm64  )\n                "linux-x64"     -> implementation(libs.doodle.desktop.jvm.linux.x64    )\n                "linux-arm64"   -> implementation(libs.doodle.desktop.jvm.linux.arm64  )\n                "windows-x64"   -> implementation(libs.doodle.desktop.jvm.windows.x64  )\n                "windows-arm64" -> implementation(libs.doodle.desktop.jvm.windows.arm64)\n            }\n        }\n    }\n}\n\napplication {\n    mainClass.set("io.nacular.doodle.examples.MainKt")\n}\n\ninstallFullScreenDemo("Development")\ninstallFullScreenDemo("Production" )';var d=t(854),c=t(9053);const h={title:"Calculator",hide_title:!0},u="Calculator Tutorial",p={id:"calculator",title:"Calculator",description:"Our goal is to build the following calculator app using Doodle. This is a simple calculator that only performs addition, subtraction, multiplication, and division. It also supports negative values, decimals, and has a convenience function for converting to a percentage.",source:"@site/docs/calculator.mdx",sourceDirName:".",slug:"/calculator",permalink:"/doodle-tutorials/docs/calculator",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Calculator",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Contacts",permalink:"/doodle-tutorials/docs/contacts"},next:{title:"Todo",permalink:"/doodle-tutorials/docs/todo"}},m={},x=[{value:"Project Setup",id:"project-setup",level:2},{value:"Defining Our Application",id:"defining-our-application",level:2},{value:"Launching on Web and Desktop",id:"launching-on-web-and-desktop",level:2},{value:"Creating A Fullscreen Web App",id:"creating-a-fullscreen-web-app",level:2},{value:"The Calculator View",id:"the-calculator-view",level:2},{value:"Calculator Output",id:"calculator-output",level:3},{value:"More Dependencies",id:"more-dependencies",level:2},{value:"The Buttons",id:"the-buttons",level:2},{value:"Button Styling",id:"button-styling",level:2},{value:"Custom Hit Detection",id:"custom-hit-detection",level:2},{value:"Testing",id:"testing",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",mermaid:"mermaid",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"calculator-tutorial",children:[(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/tree/master/Calculator",children:"Calculator"})," Tutorial"]}),"\n",(0,i.jsx)(n.p,{children:"Our goal is to build the following calculator app using Doodle. This is a simple calculator that only performs addition, subtraction, multiplication, and division. It also supports negative values, decimals, and has a convenience function for converting to a percentage."}),"\n",(0,i.jsx)(n.p,{children:"However, it does not have more advanced features, like parentheses, or other math operations. This means the implementation is simpler, and we can focus on the way Doodle is used instead of the complexity of the app itself. Play around with the calculator to get a feel for it."}),"\n",(0,i.jsx)(c.I,{function:"calculator",height:"500"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can also see the full-screen apps here: ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/calculator",children:"JavaScript"}),", ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle-tutorials/calculator_wasm",children:"WebAssembly"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,i.jsxs)(n.p,{children:["We will use a multi-platform library setup for this app, with a multiplatform launcher that depends on it. This is not necessary to use Doodle. You could create a single multiplatform build with the common parts of your app in ",(0,i.jsx)(n.code,{children:"commonMain"})," etc.. This setup is used here because these apps are also launched by an app within ",(0,i.jsx)(n.code,{children:"DocApps"})," when embedding them like below. Therefore, we need a pure library for each app. This is why there is an app and a runner."]}),"\n",(0,i.jsx)(n.mermaid,{value:" classDiagram\n      Calculator <|-- CalculatorRunner\n      Calculator <|-- DocApps\n      CalculatorRunner: jvmMain.main\n      CalculatorRunner: jsMain.main\n      DocApps         : main"}),"\n",(0,i.jsxs)(a.A,{children:[(0,i.jsxs)(l.A,{value:"Calculator",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/build.gradle.kts",children:(0,i.jsx)(n.strong,{children:"build.gradle.kts"})})}),(0,i.jsx)(d.v,{children:s})]}),(0,i.jsxs)(l.A,{value:"CalculatorRunner",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/CalculatorRunner/build.gradle.kts",children:(0,i.jsx)(n.strong,{children:"build.gradle.kts"})})}),(0,i.jsx)(d.v,{children:r})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Build uses ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/gradle/libs.versions.toml",children:"libs.versions.toml"})," file."]})}),"\n",(0,i.jsx)(n.h2,{id:"defining-our-application",children:"Defining Our Application"}),"\n",(0,i.jsxs)(n.p,{children:["All Doodle apps must implement the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:(0,i.jsx)(n.code,{children:"Application"})})," interface. The framework will then initialize our app via the constructor. Our app will be fairly simple: just create an instance of our calculator and add it to the display."]}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps can be defined in ",(0,i.jsx)(n.code,{children:"commonMain"}),", since they do not require any platform-specific dependencies. Therefore, we will do the same and place ours in ",(0,i.jsx)(n.code,{children:"commonMain/kotlin/io/nacular/doodle/examples"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/CalculatorApp.kt#L11",children:(0,i.jsx)(n.strong,{children:"CalculatorApp.kt"})})}),"\n",(0,i.jsx)(d.v,{children:"\npackage io.nacular.doodle.examples\n\n\n// ...\n\n\nclass CalculatorApp(display: Display): Application {\n    init {\n        // creat and display a single Calculator\n        display += Calculator()\n    }\n\n\n    override fun shutdown() { /* no-op */ }\n}\n"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:"shutdown"})," is a no-op, since we don't have any cleanup to do when the app closes."]})}),"\n",(0,i.jsx)(n.h2,{id:"launching-on-web-and-desktop",children:"Launching on Web and Desktop"}),"\n",(0,i.jsxs)(n.p,{children:["Doodle apps can be ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications",children:"launched"})," in a few different ways on Web and Desktop. We defined our app logic in a multi-platform ",(0,i.jsx)(n.code,{children:"Calculator"})," library (no ",(0,i.jsx)(n.code,{children:"main"})," functions), so it can be used on both platforms. Notice that we are only using a library here because we also want to run the Calculator in our documentation app. That app will run it as an embedded Web app, which becomes easier if it is a library. Otherwise, we could have defined our platform ",(0,i.jsx)(n.code,{children:"main"})," functions directly in the ",(0,i.jsx)(n.code,{children:"Calculator"})," module. Instead, we created a separate ",(0,i.jsx)(n.code,{children:"CalculatorRunner"})," module that contains our ",(0,i.jsx)(n.code,{children:"main"})," functions."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-fullscreen-web-app",children:"Creating A Fullscreen Web App"}),"\n",(0,i.jsxs)(n.p,{children:["We create a helper to launch the app in ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/applications#top-level-apps",children:"full screen"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/jsMain/kotlin/io/nacular/doodle/examples/FullScreen.kt#L12",children:(0,i.jsx)(n.strong,{children:"FullScreen.kt"})})}),"\n",(0,i.jsx)(d.v,{children:"\npackage io.nacular.doodle.examples\n\n\n//...\n\n\nfun fullScreen() {\n    application(modules = listOf(PointerModule)) {\n        // load app\n        CalculatorApp(instance()) // provide the Display\n    }\n}\n"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Normally this would just be your ",(0,i.jsx)(n.code,{children:"main"})," function, but this would prevent the app from being used as a library. Which is what happens to allow both an embedded (in the docs) and full-screen version."]})}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"application"})," function to launch top-level apps. It takes a list of modules to and a lambda that builds the app. This lambda is within a Kodein injection context, which means we can inject dependencies into our app via ",(0,i.jsx)(n.code,{children:"instance"}),", ",(0,i.jsx)(n.code,{children:"provider"}),", etc."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we have included the ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/pointer_input/overview",children:(0,i.jsx)(n.code,{children:"PointerModule"})}),". This is needed to enable mouse or pointer interactions. Our app will not directly know we loaded this module, but pointer related events will only work because we have."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Check out Kodein to learn more about how it handles dependency injection."})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"application"})," function also takes an optional HTML element within which the app will be hosted. The app will be hosted in\n",(0,i.jsx)(n.code,{children:"document.body"})," if no element is specified."]}),"\n",(0,i.jsx)(n.p,{children:"App launching is the only part of our code that is platform-specific. This makes sense, since it is the only time we might need to know about an HTML element; say when embedding our app in a non-Doodle context."}),"\n",(0,i.jsx)(n.h2,{id:"the-calculator-view",children:"The Calculator View"}),"\n",(0,i.jsxs)(n.p,{children:["We will implement our calculator as a single ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/views",children:(0,i.jsx)(n.code,{children:"View"})})," that manages its state directly. This makes sense for simple use-cases, but might not be the right choice for larger apps."]}),"\n",(0,i.jsxs)(n.p,{children:["This View will be broken into a hierarchy of views, with two top-level items: a custom output and a ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/ui_components/overview#gridpanel",children:(0,i.jsx)(n.code,{children:"GridPanel"})}),"."]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)("img",{src:"/doodle-tutorials/calc-top2.png",alt:"calculator top"}),"\n",(0,i.jsx)("img",{src:"/doodle-tutorials/calc-bottom2.png",alt:"calculator bottom",style:{float:"right"}}),"\n",(0,i.jsx)(n.h3,{id:"calculator-output",children:"Calculator Output"}),"\n",(0,i.jsx)(n.p,{children:'The Output will be a really simple View that tracks a number and its text representation, which it will render to the screen. It will also expose the number as the current "answer" on the calculator. Its most complex role is displaying the text with proper alignment and scaling to avoid any clipping.'}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Notice how the output text starts off center aligned with the operator buttons; and how it shrinks as the number grows beyond the screen size."})}),"\n",(0,i.jsxs)(n.p,{children:["Take a look at the ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L48",children:(0,i.jsx)(n.strong,{children:"Output"})})," class, and you will see it has a ",(0,i.jsx)(n.code,{children:"text"})," property that it tracks the width of. It also uses ",(0,i.jsx)(n.code,{children:"textTransform"})," to perform the text scaling."]}),"\n",(0,i.jsx)(d.v,{children:'\nprivate inner class Output: View() {\n    //...\n\n\n    // Transform used to scale text down as it grows beyond window width\n    private var textTransform = Identity\n\n\n    //...\n\n\n    /** Text representation of number */\n    var text = "0"\n        set(new) {\n            field = new\n\n            val textWidth   = textMetrics.width(field, font)\n            val windowWidth = width - inset * 2\n\n\n            // use transform when text grows beyond window width\n            textTransform = when {\n                textWidth > windowWidth -> (windowWidth/textWidth).let { Identity.scale(x = it, y = it, around = Point(width / 2, height)) }\n                else                    -> Identity\n            }\n\n\n            rerender()\n        }\n\n\n    //...\n\n\n    override fun render(canvas: Canvas) {\n        val textPosition = textMetrics.size(text, font).let {\n            val x = when {\n                textTransform.isIdentity -> width - it.width - inset\n                else                     -> (width - it.width) / 2\n            }\n\n\n            Point(x, height - it.height)\n        }\n\n\n        // scaling, if present, is applied to the canvas before text rendered\n        canvas.transform(textTransform) {\n            text(text, at = textPosition, font = font, color = foregroundColor ?: White)\n        }\n    }\n}\n'}),"\n",(0,i.jsx)(n.h2,{id:"more-dependencies",children:"More Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Output"})," class, and others in ",(0,i.jsx)(n.code,{children:"Calculator"})," need things like fonts, and the ability to measure text. Doodle provides these capabilities via interfaces like ",(0,i.jsx)(n.code,{children:"FontDetector"})," and ",(0,i.jsx)(n.code,{children:"TextMetrics"}),". These can be provided to ",(0,i.jsx)(n.code,{children:"Calculator"})," via constructor injection."]}),"\n",(0,i.jsx)(n.p,{children:"That results in a constructor as follows:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L35",children:(0,i.jsx)(n.strong,{children:"Calculator.kt"})})}),"\n",(0,i.jsx)(d.v,{children:"\nclass Calculator(\n        private val fonts          : FontDetector,\n        private val textMetrics    : TextMetrics,\n        private val numberFormatter: NumberFormatter\n): View() {\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["This means ",(0,i.jsx)(n.code,{children:"CalculatorApp"})," needs to be updated as well. We continue by injecting these dependencies there as well."]}),"\n",(0,i.jsx)(d.v,{children:"\npackage io.nacular.doodle.examples\n\n\n// ...\n\n\nclass CalculatorApp(\n        display        : Display,\n        textMetrics    : TextMetrics,\n        fontDetector   : FontDetector,\n        numberFormatter: NumberFormatter\n): Application {\n    init {\n        // creat and display a single Calculator\n        display += Calculator(fontDetector, textMetrics, numberFormatter)\n    }\n\n\n    override fun shutdown() { /* no-op */ }\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["Now ",(0,i.jsx)(n.code,{children:"Main"})," needs to provide these, along with Display, when constructing the app."]}),"\n",(0,i.jsx)(d.v,{children:'\npackage io.nacular.doodle.examples\n\n//...\n\nfun main() {\n    application(modules = listOf(\n        PointerModule,\n        Module(name = "AppModule") {\n            // Used to get fonts that should\'ve been loaded\n            bind<FontDetector>() with singleton { FontDetectorImpl(instance(), instance(), instance()) }\n        }\n    )) {\n        // load app\n        CalculatorApp(instance(), instance(), instance(), NumberFormatterImpl())\n    }\n}\n'}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"TextMetrics"}),", ",(0,i.jsx)(n.code,{children:"FontDetector"})," is not included in Doodle's default modules, so we have to wire it explicitly. We define a new ",(0,i.jsx)(n.code,{children:"Module"})," to do so because it has dependencies that can be injected as well."]})}),"\n",(0,i.jsx)(n.h2,{id:"the-buttons",children:"The Buttons"}),"\n",(0,i.jsxs)(n.p,{children:["We can manage the set of buttons within the calculator with a ",(0,i.jsx)(n.code,{children:"GridPanel"}),". This way we get the layout support it provides. This results in the following initialization for ",(0,i.jsx)(n.code,{children:"Calculator"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/Calculator.kt#L35",children:(0,i.jsx)(n.strong,{children:"Calculator.kt"})})}),"\n",(0,i.jsx)(d.v,{children:"\nclass Calculator(/*...*/): View() {\n\n\n    //...\n\n\n    init {\n        GlobalScope.launch {\n            loadFonts()\n\n            ButtonGroup(allowDeselectAll = true, buttons = *arrayOf(`\xf7`, `*`, `-`, `+`))\n\n\n            val outputHeight  = 100.0\n            val buttonSpacing =  10.0\n\n\n            val gridPanel = GridPanel().apply {\n                add(clear, 0, 0); add(negate, 0, 1); add(`\xf7`, 0, 2); add(`\xf7`, 0, 3)\n                add(`7`,   1, 0); add(`8`,    1, 1); add(`9`, 1, 2); add(`*`, 1, 3)\n                add(`4`,   2, 0); add(`5`,    2, 1); add(`6`, 2, 2); add(`-`, 2, 3)\n                add(`1`,   3, 0); add(`2`,    3, 1); add(`3`, 3, 2); add(`+`, 3, 3)\n                add(`0`,   4, 0,  columnSpan = 2  ); add(decimal, 4, 2); add(`=`,  4, 3)\n\n\n                verticalSpacing   = buttonSpacing\n                horizontalSpacing = buttonSpacing\n            }\n\n\n            children += listOf(output, gridPanel)\n\n\n            // Place output outside grid so the height can be more easily controlled\n            val constraints = constrain(output, gridPanel) { output, grid ->\n                output.top    = parent.top\n                output.left   = parent.left\n                output.right  = parent.right\n                output.height = constant(outputHeight)\n\n                grid.top      = output.bottom + buttonSpacing\n                grid.left     = output.left\n                grid.right    = output.right\n                grid.bottom   = parent.bottom\n            }\n\n\n            layout = object: Layout by constraints {\n                // Set total height to grid panel's ideal width and height, plus output and spacing\n                override fun idealSize(container: PositionableContainer, default: Size?) = gridPanel.idealSize?.let {\n                    Size(it.width, it.height + outputHeight + buttonSpacing)\n                }\n            }\n\n\n            // Force idealSize when gridPanel is laid out\n            gridPanel.sizePreferencesChanged += { _,_,new ->\n                idealSize = new.idealSize?.let { Size(it.width, it.height + outputHeight + buttonSpacing) }\n            }\n        }\n    }\n\n\n    //...\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["The initialization steps are: ",(0,i.jsx)(n.strong,{children:"(1) load fonts"}),", ",(0,i.jsx)(n.strong,{children:"(2) setup buttons in GridPanel"}),", ",(0,i.jsx)(n.strong,{children:"(3) add Output and grid as children"}),", ",(0,i.jsx)(n.strong,{children:"(4) configure the layout"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This example uses non-standard/recommended property names for buttons to improve readability slightly. This also makes tests a little simpler to understand."}),"\n",(0,i.jsx)(n.h2,{id:"button-styling",children:"Button Styling"}),"\n",(0,i.jsxs)(n.p,{children:["The calculator buttons come in a few different color schemes. But they all share the same ",(0,i.jsx)(n.a,{href:"https://nacular.github.io/doodle/docs/rendering/behaviors",children:(0,i.jsx)(n.code,{children:"Behavior"})}),", defined by ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/commonMain/kotlin/io/nacular/doodle/examples/CalcButtonBehavior.kt#L16",children:(0,i.jsx)(n.code,{children:"CalcButtonBehavior"})}),". Buttons--like many Views--let you define their look-and-feel using a ",(0,i.jsx)(n.code,{children:"Behavior"}),". Ours is fairly simple; it draws the rounded rectangle for the button background and centers the text above it. These are both managed with the right color based on the button's state. It gets state tracking and text positioning for free via its base class: ",(0,i.jsx)(n.code,{children:"CommonTextButtonBehavior"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"custom-hit-detection",children:"Custom Hit Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CalcButtonBehavior"})," provides a rounded style for our buttons. But the default hit-detection for Views is tied to their rectangular bounds. We can fix this by writing custom pointer hit-detection in our behavior."]}),"\n",(0,i.jsx)(d.v,{children:"\nclass CalcButtonBehavior(textMetrics: TextMetrics): CommonTextButtonBehavior<Button>(textMetrics) {\n    //...\n\n\n    override fun contains(view: Button, point: Point): Boolean {\n        val radius      = view.height / 2\n        val leftCircle  = Circle(center = Point(view.x + radius,            view.center.y), radius = radius)\n        val rightCircle = Circle(center = Point(view.bounds.right - radius, view.center.y), radius = radius)\n\n\n        return when {\n            point.x < radius              -> point in leftCircle\n            point.x > view.width - radius -> point in rightCircle\n            else                          -> point in view.bounds\n        }\n    }\n}\n"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contains(Button, Point)"})," method is called by ",(0,i.jsx)(n.code,{children:"Button"}),' to check whether the pointer is within its bounds. This logic ensures the pointer will only "hit" our button when it goes within the rounded rectangle.']}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contains"})," check provides a ",(0,i.jsx)(n.code,{children:"Point"})," in the View's ",(0,i.jsx)(n.strong,{children:"parent's"})," coordinates."]})}),"\n",(0,i.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,i.jsxs)(n.p,{children:["Common code testing is one reason to use a multi-platform setup. Doodle is designed to avoid platform specific dependencies except in the small amount of launch code. This means we can easily test ",(0,i.jsx)(n.code,{children:"Calculator"})," and the other components by writing tests in ",(0,i.jsx)(n.code,{children:"commonTest"})," and running them on the JVM target. One advantage is the speed of running these tests, since there are no external dependencies."]}),"\n",(0,i.jsxs)(n.p,{children:["The tests in ",(0,i.jsx)(n.a,{href:"https://github.com/nacular/doodle-tutorials/blob/master/Calculator/src/jvmTest/kotlin/io/nacular/doodle/examples/CalculatorTests.kt#L18",children:(0,i.jsx)(n.code,{children:"CalculatorTests"})})," are a bit contrived, but they illustrate how you might validate various parts of your app."]})]})}function b(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);